<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.0.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.0" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="tags">
<meta property="og:url" content="http://yoursite.com/tags/index.html">
<meta property="og:site_name" content="ruirui&#39;s blog">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2021-09-30T15:10:00.074Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="tags">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/tags/">





  <title>ruirui's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ruirui's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">ruirui's 备忘录</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/18/http-sign/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ruirui">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ruirui's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/18/http-sign/" itemprop="url">前端请求签名方案</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-01-18T13:11:48+08:00">2021-01-18</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近参与开发公司一个重要的数据产品，因为数据安全级别要求较高，常用的权限控制方案无法防止用户通过接口或爬虫工具进行恶意访问和数据抓取，故设计此方案用于保证接口安全。</p>
<p>这套方案可以起到以下防护：</p>
<ol>
<li>每次发起请求时，需通过特定算法对请求参数进行签名且后端验证通过后才会放行，避免随意抓取数据。</li>
<li>生成的签名只对本用户的本次请求（参数）有效，避免重放攻击。</li>
<li>适用于各种请求和传参方式，如GET, POST。</li>
</ol>
<h2 id="加密算法分类"><a href="#加密算法分类" class="headerlink" title="加密算法分类"></a>加密算法分类</h2><p>作为前置知识，先来介绍一下加密算法的分类。</p>
<h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>会话前双方约定一个固定的密钥，客户端用此密钥进行加密，服务端用此密钥进行解密。</p>
<p>特点：算法公开，计算量小，<strong>加密速度快</strong>。</p>
<p>常见算法：AES。</p>
<h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>两个密钥：公钥和私钥，客户端使用公钥进行加密，服务端用私钥进行解密。</p>
<p>特点：加密和解密时间长、<strong>速度慢</strong>，只适合对少量的数据进行加密。</p>
<p>使用场景：https 会话前期、CA 数字证书、信息加密等。</p>
<p>常见算法：RSA。</p>
<h3 id="Hash-算法"><a href="#Hash-算法" class="headerlink" title="Hash 算法"></a>Hash 算法</h3><p>把任意长度的输入，通过 hash 算法，变换成固定长度的输出。</p>
<p>特点：<strong>不可逆</strong>，易计算。</p>
<p>使用场景：文件或字符串一致性校验、数字签名、鉴权协议。</p>
<p>常见算法：MD5</p>
<h2 id="方案流程图"><a href="#方案流程图" class="headerlink" title="方案流程图"></a>方案流程图</h2><p><img src="flow.jpg" alt="flow"></p>
<h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><h3 id="client-端（浏览器）"><a href="#client-端（浏览器）" class="headerlink" title="client 端（浏览器）"></a>client 端（浏览器）</h3><h4 id="参数处理"><a href="#参数处理" class="headerlink" title="参数处理"></a>参数处理</h4><h5 id="GET-请求"><a href="#GET-请求" class="headerlink" title="GET 请求"></a>GET 请求</h5><p>因为 <code>GET</code> 请求传输到服务端是没有数据类型的，即服务端收到的都是字符串。所以使用 <code>url</code> 键值对的格式生成字符串。</p>
<h4 id="POST、PUT、DELETE-请求"><a href="#POST、PUT、DELETE-请求" class="headerlink" title="POST、PUT、DELETE 请求"></a>POST、PUT、DELETE 请求</h4><ol>
<li>如果 <code>content-type</code> 是 <code>application/json</code>，服务端接收到的是有数据类型的，故将 body 进行 <code>json.stringify</code> 序列化即可</li>
<li>如果 <code>content-type</code> 是 <code>application/x-www-form-urlencoded</code>，服务端收到的是类似 url 编码的形式，使用类似 <code>GET</code> 请求的方式处理</li>
<li>如果 <code>content-type</code> 是 <code>multipart/form-data</code>，为文件上传，这里不做处理</li>
</ol>
<h4 id="签名加密时-timestamp-的作用"><a href="#签名加密时-timestamp-的作用" class="headerlink" title="签名加密时 timestamp 的作用"></a>签名加密时 timestamp 的作用</h4><ol>
<li>在 server 端使用方案1 的情况下，timestamp 用于判断签名是否超时。</li>
<li>在 server 端使用方案2 的情况下，timestamp 保证每次发请求的  sign 唯一，类似于加盐，如果不让时间戳参与生成的话，相同的请求参数会生成相同的 sign，用户可以用这个 sign 一直请求，虽然不会有太大危害，但是会有不必要的业务处理。</li>
</ol>
<h3 id="server-端（node）"><a href="#server-端（node）" class="headerlink" title="server 端（node）"></a>server 端（node）</h3><h4 id="方案一，不使用-Redis："><a href="#方案一，不使用-Redis：" class="headerlink" title="方案一，不使用 Redis："></a>方案一，不使用 Redis：</h4><p>使用 timestamp 来防止接口被重复利用，客户端发请求时带上当前时间的时间戳，服务端接收到 timestamp 后与当前时间进行对比，如果时间差大于3分钟，则认为是无效请求。</p>
<p>这个方案的优点是不依赖任何组件，性能更好，但由于不能保证客户端时间（也是浏览器端时间）的准确性，此方案可能存在隐患。故采用方案二:</p>
<h4 id="方案二，使-Resis："><a href="#方案二，使-Resis：" class="headerlink" title="方案二，使 Resis："></a>方案二，使 Resis：</h4><p>使用 redis 将每次请求传过来的 sign 进行存储，如果接收到的请求 sign 存在于 redis 里，则认为是无效请求，保证每个请求只能被用一次。这种方案不依赖客户端时间，同时引入Redis后可以实现更多的功能，如服务端限流（挖个坑之后填上）。</p>
<p>server 端注意事项：在进行参数校验前，先判断是不是一个白名单（或文件上传下载）请求，如果是需要直接放行。</p>
<p>方案中配合使用了 hash 算法和对称加密算法，hash 算法用于将参与加密的数据生成一个唯一签名，因为不需要还原这个数据，所以使用了 md5 算法。之后使用 AES 将这个签名和时间戳一起进行了加密，用来传给后端。</p>
<p><img src="2.png" alt="2"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/28/node-outof-memory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ruirui">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ruirui's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/28/node-outof-memory/" itemprop="url">Node 内存溢出 —— OOM</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-12-28T11:02:19+08:00">2020-12-28</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>前几天被叫去排查一个老系统的线上问题，现象是服务不稳定，偶尔不可访问，查看监控发现服务偶尔重启，在重启前会出现内存升高一段时间，查看报错日志，在每次重启前会报 OOM（out of memory），并且每次 OOM 之前都会访问同一个接口， 线下模拟请求这个接口，发现是因为 response 数据量太大导致内存溢出，贴出报错情况。</p>
<p>FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed — process out of memory</p>
<p><img src="outof-memory.png" alt="outofmemory"></p>
<p>当为执行应用程序分配的内存少于运行应用程序所需的内存时，会发生此错误。</p>
<h2 id="内存限制"><a href="#内存限制" class="headerlink" title="内存限制"></a>内存限制</h2><p>V8的内存限制：64 位系统约为 1.4 GB，32 位系统约为 0.7 GB，即当 64 位系统中 node 使用总内存超过 1.4 G时，会报 OOM(Out Of Memory)。</p>
<h3 id="为什么会有内存限制？"><a href="#为什么会有内存限制？" class="headerlink" title="为什么会有内存限制？"></a>为什么会有内存限制？</h3><p>理论上 64 位操作系统可以访问 16TB 的空间，这比 1.4GB 要多的多！但因为以下两个原因，V8 的内存限制实际上要少的多</p>
<ol>
<li>JS （运行环境里）单线程的执行机制。</li>
<li>V8 垃圾回收机制。</li>
</ol>
<p>因为 js 是单线程运行的，执行垃圾回收会占用主线程的时间，导致<strong>全停顿（Stop-The-World）</strong>，如果垃圾回收时间过长，浏览器页面上会感受到卡顿，Node 端脚本执行被阻塞。（V8 目前针对全停顿的体验问题也有了优化方式）</p>
<blockquote>
<p>按照官方的说法以1.5G的垃圾回收为例，v8做一次小的垃圾回收需要50毫秒以上，做一次非增量的垃圾回收需要1秒以上。</p>
</blockquote>
<p>通常在内存使用量快满时，进行垃圾回收（具体机制参考<a href="/2021/01/02/v8-memory">V8 内存体系与垃圾回收</a>），内存越大，越不容易执行垃圾回收，执行一次垃圾回收耗费时间也越长，内存越少，垃圾回收越快，效率越高，所以程序减少内存使用，可以提升服务性能。</p>
<h3 id="什么情况下会耗尽内存？"><a href="#什么情况下会耗尽内存？" class="headerlink" title="什么情况下会耗尽内存？"></a>什么情况下会耗尽内存？</h3><p>如果试图装载一个比可用内存还要大的数据，就会出现内存不够的情况，导致<strong>内存溢出</strong>，进程退出。<br>另一种情况是<strong>内存泄露</strong>，本该被回收的变量，没有被回收，常驻在内存里，内存使用量会随着时间的推移而增长，最终导致内存耗尽。<br>可以通过图示来辨别内存问题<br><img src="difference.png" alt="difference"></p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>一、 产品上解决<br>数据量太大，浏览器加载及处理耗费时间太长也会导致页面卡顿，影响用户体验。</p>
<p>二、扩充内存<br>设置 <code>--max-old-space-size=4096</code> 扩充为 4G 内存，<br>注意：是下划线还是中横线，取决于 node 版本号，通过 <code>node --v8-options</code> 命令来看 V8 参数。我试了几个版本</p>
<p>8版本是下划线<br><img src="8option.png" alt="8option"></p>
<p>10版本是中横线<br><img src="10option.png" alt="10option"></p>
<p>14版本是下划线<br><img src="14option.png" alt="14option"></p>
<p>这里太坑了！！Node 版本不考虑参数兼容性，因为本地 Node 版本和线上机器 Node 版本不一致，本地测试通过发现线上没生效，找了好久原因ಥ_ಥ。</p>
<p>三、 流式解析<br>使用 buffer，buffer内存的分配是c++层面完成的，不会利用V8的堆内存。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/02/linux-update-node/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ruirui">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ruirui's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/02/linux-update-node/" itemprop="url">Linux 升级 Node</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-11-02T10:16:41+08:00">2020-11-02</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>以下为通过二进制文件升级 node 的方式</p>
<h2 id="升级-Node"><a href="#升级-Node" class="headerlink" title="升级 Node"></a>升级 Node</h2><ol>
<li><p>通过官网<a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="noopener">下载</a> linux 二进制文件安装包<br>推荐安装在/opt目录下</p>
</li>
<li><p>解压<br><code>tar -xvf node-v14.15.0-linux-x64.tar</code></p>
</li>
<li><p>设置环境变量<br>方式一： 设置 PATH 环境变量<br>   修改 /etc/profile 文件，在文件末尾添加以下内容</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export NODE_HOME=/xxx</span><br><span class="line">export PATH=$NODE_HOME/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>修改完之后，打开新的命令窗口，或者执行 <code>source /etc/profile</code> 来生效。</p>
<p>方式二： 设置软链<br> 通过 <code>which node</code> 查看 node 可执行文件路径，将本次 node 安装路径下的/bin/node 链接到 <code>which node</code>显示的路径下</p>
<blockquote>
<p>which 指令: 查看可执行文件的位置，会在环境变量 $PATH 设置的目录里查找符合条件的文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ln -s /opt/node/bin/node /usr/local/bin/node </span><br><span class="line">ln -s /opt/node/bin/npx /usr/local/bin/npx </span><br><span class="line">ln -s /opt/node/bin/npm /usr/local/bin/npm</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>以下是在操作上述过程中遇到的一些问题及知识点，在此记录</p>
<h4 id="通过-n-包管理器升级"><a href="#通过-n-包管理器升级" class="headerlink" title="通过 n 包管理器升级"></a>通过 n 包管理器升级</h4><p>清除 npm 缓存<br><code>npm cache clean -f</code><br>安装<br><code>npm install -g n</code><br>下载最新版本<br><code>n latest</code><br>下载稳定版<br><code>n stable</code><br>下载某个版本<br><code>n 版本号</code><br>切换版本<br><code>n</code></p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>硬链接：每个文件都有一个硬链接，硬链接和文件没什么区别。<br>软链接（符号链接）：类似 window 的快捷方式，软链接可以关联一个目录，硬链接不行。</p>
<p><strong>创建链接 ln</strong><br>-s 表示创建软链<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/bin/npm /opt/soft/node-v14.15.0/bin/npm</span><br></pre></td></tr></table></figure></p>
<p><strong>查看文件路径 ls -l</strong><br>如果文件或目录是软链，-&gt; 后面是链接的真实路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@3e5830d31dce bin]# ls -l | grep node</span><br><span class="line">lrwxrwxrwx   1 root  root          27 10月 29 19:34 n -&gt; ../lib/node_modules/n/bin/n</span><br><span class="line">lrwxrwxrwx   1 root  root          42 10月 29 20:49 node -&gt; /opt/soft/node-v14.15.0-linux-x64/bin/node</span><br><span class="line">lrwxrwxrwx   1 root  root          41 10月 29 21:06 npm -&gt; /opt/soft/node-v14.15.0-linux-x64/bin/npm</span><br><span class="line">lrwxrwxrwx   1 root  root          41 10月 29 21:07 npx -&gt; /opt/soft/node-v14.15.0-linux-x64/bin/npx</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/26/single-spa-source-code-analyze/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ruirui">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ruirui's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/26/single-spa-source-code-analyze/" itemprop="url">single-spa 源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-26T14:43:51+08:00">2020-03-26</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在了解single-spa基本功能后，可以将其简单概括为：single-spa 的核心就是动态将子应用的资源文件插入到主应用中。那内部是如何管理子应用、如何做到子应用之间的动态切换。带着这些疑问探究 single-spa 源码。</p>
<p>源码主要分为三部分：app 应用、Navigation 路由、生命周期。</p>
<h2 id="application"><a href="#application" class="headerlink" title="application"></a>application</h2><h3 id="应用状态"><a href="#应用状态" class="headerlink" title="应用状态"></a>应用状态</h3><p>为了更好的管理 app，每个app在运行期间都有自己的状态<br>每个应用在整个运行期间都有自己的状态，根据不同状态做对应的处理。</p>
<ul>
<li>null ： app 不存在</li>
<li>NOT_LOADED：已经注册还没加载</li>
<li>LOADING_SOURCE_CODE：正在加载 app 代码（registerApplication 的第二个参数）</li>
<li>NOT_BOOTSTRAPPED：已经加载还没启动，即未执行 app 的 bootstrap 生命周期函数</li>
<li>BOOTSTRAPPING：正在启动，执行 app 的 bootstrap 生命周期函数，只执行一次</li>
<li>NOT_MOUNTED：已经启动还没挂载</li>
<li>MOUNTING： 正在挂载，执行 app 的 mount 函数</li>
<li>MOUNTED：已经挂载</li>
<li>UNMOUNTING：正在移除挂载，执行 app 的 unmount 函数</li>
<li>UNLOADING： 正在卸载，还没完成</li>
<li>SKIP_BECAUSE_BROKEN：执行期间出错</li>
</ul>
<h3 id="注册应用"><a href="#注册应用" class="headerlink" title="注册应用"></a>注册应用</h3><p>框架内部统一管理所有应用来进行应用之间的调度（应用的挂载卸载错误等处理），应用注册成功后，会放到内部统一管理应用的的数组 apps 里。<br><code>registerApplication：（appName，applicationOrLoadingFn，activeFn， customProps）</code></p>
<ul>
<li>appName： 应用唯一标识。</li>
<li>applicationOrLoadingFn： <strong>入口 js 文件，这就需要子应用做一些处理，需要打包成特殊的文件格式进行加载</strong></li>
<li>activeFn：什么时候激活应用，根据 url 进行匹配。</li>
<li>customProps：给子应用传递的参数，例如登录信息权限控制等。</li>
</ul>
<p>注册成功之后的单个 app 信息如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">apps.push(&#123;</span><br><span class="line">    loadErrorTime: <span class="literal">null</span>,</span><br><span class="line">    name: appName,</span><br><span class="line">    loadImpl,</span><br><span class="line">    activeWhen: activityFn,</span><br><span class="line">    status: NOT_LOADED,</span><br><span class="line">    parcels: &#123;&#125;,</span><br><span class="line">    devtools: &#123;</span><br><span class="line">      overlays: &#123;</span><br><span class="line">        options: &#123;&#125;,</span><br><span class="line">        selectors: [],</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    customProps</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>除了注册传递的参数以外，single-spa 给每个 app 增加了状态 status。注册后的状态为 NOT_LOADED，表示已经注册但未加载。<br>注册成功后，会执行 reroute 方法，reroute 内部判断是否已经 start，如果未启动，则找到匹配的应用（不报错的、还未 load 的）进行<strong>预加载</strong>，为挂载做准备。如果已经启动，则取消已经挂载的，找到当前匹配的进行挂载，reroute 是整个 single-app 的核心，后面还会详细分析。</p>
<h3 id="卸载应用"><a href="#卸载应用" class="headerlink" title="卸载应用"></a>卸载应用</h3><p><code>unregisterApplication</code> 会去调用 <code>unloadApplication</code>，然后在 apps 里找到对应的 app 将其删除。<br>在 <code>unloadApplication</code> 里，会先去看当前应用是否有正在被 <code>unload</code>，如果存在则直接返回。否则需要先 <code>unmount</code> 之后再去 <code>unload</code>。</p>
<h2 id="Navigation"><a href="#Navigation" class="headerlink" title="Navigation"></a>Navigation</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'hashchange'</span>, urlReroute);</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'popstate'</span>, urlReroute);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">urlReroute</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  reroute([], <span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>全局监听了 <code>hashchange</code> 和 <code>popstate</code> 事件来拦截 url 的变化，在路由事件到达应用框架（Vue、React）之前做应用的挂载卸载处理，当触发这两个事件后，也会执行 reroute，同时带上事件参数传递给 reroute。下面重点分析一下 reroute。</p>
<h2 id="reroute"><a href="#reroute" class="headerlink" title="reroute"></a>reroute</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">reroute 接收两个参数</span></span><br><span class="line"><span class="comment">pendingPromises：表示正在队列中等待执行的 reroute。reroute 在执行期间，可能会有多个 reroute 被调用（路由触发或者应用注册）。</span></span><br><span class="line"><span class="comment">eventArguments：路由事件触发的 event。只有路由改变才会有这个参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reroute</span>(<span class="params">pendingPromises = [], eventArguments</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// appChangeUnderway 是一个开关，用来表示 reroute 是否正处于执行期间。</span></span><br><span class="line">  <span class="comment">// 如果正处于执行期间还会有 reroute 要执行，则会将 reroute 放入队列里等待执行</span></span><br><span class="line">  <span class="keyword">if</span> (appChangeUnderway) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      peopleWaitingOnAppChange.push(&#123;</span><br><span class="line">        resolve,</span><br><span class="line">        reject,</span><br><span class="line">        eventArguments,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  appChangeUnderway = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// wasNoOp 为 true 表示没有应用发生变更。</span></span><br><span class="line">  <span class="keyword">let</span> wasNoOp = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isStarted()) &#123;</span><br><span class="line">    <span class="keyword">return</span> performAppChanges();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> loadApps();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">loadApps</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> loadPromises = getAppsToLoad().map(toLoadPromise);</span><br><span class="line">      <span class="comment">// 获取要 load 的 app（未出错的命中的），如果有说明应用发生了变更</span></span><br><span class="line">      <span class="keyword">if</span> (loadPromises.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        wasNoOp = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 执行 load 并且直接 finishUpAndReturn</span></span><br><span class="line">      <span class="comment">// 并不进行 mount，因为未 start，此时进行预加载</span></span><br><span class="line">      <span class="comment">// 即：页面上没有挂载该应用，但是会去请求对应的资源文件</span></span><br><span class="line">      <span class="comment">// 不会去调用应用文件里的bootstrap、mount、unmount等生命周期</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span></span><br><span class="line">        .all(loadPromises)</span><br><span class="line">        .then(finishUpAndReturn)</span><br><span class="line">        .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">          callAllEventListeners();</span><br><span class="line">          <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">performAppChanges</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">window</span>.dispatchEvent(<span class="keyword">new</span> CustomEvent(<span class="string">"single-spa:before-routing-event"</span>, getCustomEventDetail()));</span><br><span class="line">      <span class="keyword">const</span> unloadPromises = getAppsToUnload().map(toUnloadPromise);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> unmountUnloadPromises = getAppsToUnmount()</span><br><span class="line">        .map(toUnmountPromise)</span><br><span class="line">        .map(<span class="function"><span class="params">unmountPromise</span> =&gt;</span> unmountPromise.then(toUnloadPromise));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> allUnmountPromises = unmountUnloadPromises.concat(unloadPromises);</span><br><span class="line">      <span class="comment">// 获取要 unload 以及要 unmout 的 app，如果有表示应用发生了变更</span></span><br><span class="line">      <span class="comment">// 如果此时触发的是子应用内部的路由，则此时 allUnmountPromises 为[]，表示没有应用的卸载或挂载</span></span><br><span class="line">      <span class="keyword">if</span> (allUnmountPromises.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        wasNoOp = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> unmountAllPromise = <span class="built_in">Promise</span>.all(allUnmountPromises);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> appsToLoad = getAppsToLoad();</span><br><span class="line">      <span class="comment">// 在其他应用 unmounting 期间将需要 load 的 app 执行 load、bootstrap（并行优势），等所有的 unmounting 都结束之后去挂载当前的 app</span></span><br><span class="line">      <span class="keyword">const</span> loadThenMountPromises = appsToLoad.map(<span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> toLoadPromise(app)</span><br><span class="line">          .then(toBootstrapPromise)</span><br><span class="line">          .then(<span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> unmountAllPromise</span><br><span class="line">              .then(<span class="function"><span class="params">()</span> =&gt;</span> toMountPromise(app))</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="comment">// 如果有要挂载的 app，也说明应用发生了变更</span></span><br><span class="line">      <span class="keyword">if</span> (loadThenMountPromises.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        wasNoOp = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 获取已经 bootstrap 要去 mount 的 app，同上，等到其他 app unmounting 之后执行挂载</span></span><br><span class="line">      <span class="keyword">const</span> mountPromises = getAppsToMount()</span><br><span class="line">        .filter(<span class="function"><span class="params">appToMount</span> =&gt;</span> appsToLoad.indexOf(appToMount) &lt; <span class="number">0</span>)</span><br><span class="line">        .map(<span class="function"><span class="params">appToMount</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> toBootstrapPromise(appToMount)</span><br><span class="line">            .then(<span class="function"><span class="params">()</span> =&gt;</span> unmountAllPromise)</span><br><span class="line">            .then(<span class="function"><span class="params">()</span> =&gt;</span> toMountPromise(appToMount))</span><br><span class="line">        &#125;)</span><br><span class="line">      <span class="comment">// 同上</span></span><br><span class="line">      <span class="keyword">if</span> (mountPromises.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        wasNoOp = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 所有要卸载的执行完之后，执行回调</span></span><br><span class="line">      <span class="keyword">return</span> unmountAllPromise</span><br><span class="line">        .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">          callAllEventListeners();</span><br><span class="line">          <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          callAllEventListeners();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Promise</span></span><br><span class="line">            .all(loadThenMountPromises.concat(mountPromises))</span><br><span class="line">            .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">              pendingPromises.forEach(<span class="function"><span class="params">promise</span> =&gt;</span> promise.reject(err));</span><br><span class="line">              <span class="keyword">throw</span> err;</span><br><span class="line">            &#125;)</span><br><span class="line">            .then(<span class="function"><span class="params">()</span> =&gt;</span> finishUpAndReturn(<span class="literal">false</span>))</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">finishUpAndReturn</span>(<span class="params">callEventListeners=true</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> returnValue = getMountedApps();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (callEventListeners) &#123;</span><br><span class="line">      callAllEventListeners();</span><br><span class="line">    &#125;</span><br><span class="line">    pendingPromises.forEach(<span class="function"><span class="params">promise</span> =&gt;</span> promise.resolve(returnValue));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> appChangeEventName = wasNoOp ? <span class="string">"single-spa:no-app-change"</span>: <span class="string">"single-spa:app-change"</span>;</span><br><span class="line">      <span class="built_in">window</span>.dispatchEvent(<span class="keyword">new</span> CustomEvent(appChangeEventName, getCustomEventDetail()));</span><br><span class="line">      <span class="built_in">window</span>.dispatchEvent(<span class="keyword">new</span> CustomEvent(<span class="string">"single-spa:routing-event"</span>, getCustomEventDetail()));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打开开关，执行队列里的 reroute</span></span><br><span class="line">    appChangeUnderway = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 虽然批量执行所有等待的 reroute，但这个地方还是需要递归的执行，因为在执行 reroute 期间可能又会有 reroute 进来</span></span><br><span class="line">    <span class="keyword">if</span> (peopleWaitingOnAppChange.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> nextPendingPromises = peopleWaitingOnAppChange;</span><br><span class="line">      peopleWaitingOnAppChange = [];</span><br><span class="line">      reroute(nextPendingPromises);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> returnValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">callAllEventListeners</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    pendingPromises.forEach(<span class="function"><span class="params">pendingPromise</span> =&gt;</span> &#123;</span><br><span class="line">      callCapturedEventListeners(pendingPromise.eventArguments);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    callCapturedEventListeners(eventArguments);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getCustomEventDetail</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = &#123;<span class="attr">detail</span>: &#123;&#125;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eventArguments &amp;&amp; eventArguments[<span class="number">0</span>]) &#123;</span><br><span class="line">      result.detail.originalEvent = eventArguments[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>画个简易的流程图如下：<br><img src="reroute.png" alt="reroute"></p>
<h2 id="lifecycles"><a href="#lifecycles" class="headerlink" title="lifecycles"></a>lifecycles</h2><p>single-spa 的亮点除了顶层路由的设计，另一个亮点就是生命周期的设计。生命周期的设计使得主应用更好的控制子应用。整个生命周期状态变更如下:<br><img src="lifecycle.png" alt="lifecycle"></p>
<p>app 出错的状态有两个：<code>SKIP_BECAUSE_BROKEN</code> 与 <code>LOAD_ERROR</code>。<code>SKIP_BECAUSE_BROKEN</code> 表示在状态变更时出错，阻止往下个状态变更，<code>LOAD_ERROR</code> 表示加载错误，此时会记录当前的时间戳，当路由再次导航到对应用时还会尝试去加载（时间间隔大于200ms）。<br>挂载阶段出错时，在状态变成 <code>SKIP_BECAUSE_BROKEN</code> 之前需要先将状态变成 <code>mounted</code>，因为出错后要执行 <code>toUnmountPromise</code> 卸载应用，而 <code>toUnmountPromise</code> 会判断如果状态不是 <code>MOUNTED</code> 时会跳过。</p>
<h2 id="single-spa-react"><a href="#single-spa-react" class="headerlink" title="single-spa-react"></a>single-spa-react</h2><p>上面提到，在加载应用资源时，会去检查 app 的三个生命周期状态，single-spa 要求接入的应用都提供这三个生命周期，所以官方官方适配出了各个框架的工具。以single-spa-react 为例，react 应用的入口文件通过 single-spa-react 封装，暴露给 single-spa 三个生命周期函数，并且都是 Promise。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> defaultOpts = &#123;</span><br><span class="line">  <span class="comment">// required opts</span></span><br><span class="line">  React: <span class="literal">null</span>,</span><br><span class="line">  ReactDOM: <span class="literal">null</span>,</span><br><span class="line">  rootComponent: <span class="literal">null</span>,</span><br><span class="line">  loadRootComponent: <span class="literal">null</span>,</span><br><span class="line">  suppressComponentDidCatchWarning: <span class="literal">false</span>,</span><br><span class="line">  domElements: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// optional opts</span></span><br><span class="line">  domElementGetter: <span class="literal">null</span>,</span><br><span class="line">  parcelCanUpdate: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">singleSpaReact</span>(<span class="params">userOpts</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> opts = &#123;</span><br><span class="line">    ...defaultOpts,</span><br><span class="line">    ...userOpts,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> lifecycles = &#123;</span><br><span class="line">    bootstrap: bootstrap.bind(<span class="literal">null</span>, opts),</span><br><span class="line">    mount: mount.bind(<span class="literal">null</span>, opts),</span><br><span class="line">    unmount: unmount.bind(<span class="literal">null</span>, opts),</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> lifecycles</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>bootstrap: 如果是 class 或者无状态组件，则直接返回。确保传入的是 React 根组件。</li>
<li>mount: 找到 single-spa 传递给应用的 DOM 节点(domElementGetter)，执行 reactDomRender 进行渲染。</li>
<li>unmount: 从 DOM 中移除 React 应用。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/05/2019-reading-notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ruirui">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ruirui's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/05/2019-reading-notes/" itemprop="url">2019年读书笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-05T23:21:57+08:00">2020-01-05</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>自从脱离了学校之后，发现自己对文字和语言的感知特别弱，和别人交流看过的书或者电影时，惊讶的发现大部分时候只记得书名，书里描述的具体场景及情节忘的一干二净哪怕当时阅读时感觉多么好看多么有共鸣，这种感受多了之后其实有点痛苦甚至失望，于是19年想着能把读过的书以及当时的感受记录下来，也算是一种积累或者回忆。</p>
<h1 id="美妙的新世界"><a href="#美妙的新世界" class="headerlink" title="美妙的新世界"></a>美妙的新世界</h1><p>2018-12-20<br>这是我读的第一本乌托邦的书籍，看《奇葩说》辩论时詹青云提到的。</p>
<blockquote>
<p>“新世界”相信一种理论：”道德教育都是不能诉诸理论的。” 因此都在下意识进行。<br>“新世界”有一条规定：”智力和工作是成年人，感情和欲望是孩子”</p>
</blockquote>
<p>新世界的宗旨是: 一切为了稳定。当人们出现一点痛苦，服用唆麻便可以化解。<br>读完这本书，感觉到更多的是可怕和悲哀，新世界人们像是一个个流水线上的生产出来的机器，从最原始材料的不同就被划分不同的社会阶级，人和人之间不是平等的，每个人是有具体社会职责的，都是为了看似和谐美好高效的社会在运转。然而缩短劳动力的时间并不会使社会更稳定，提高效率并不会使每个人更幸福。</p>
<h1 id="局外人"><a href="#局外人" class="headerlink" title="局外人"></a>局外人</h1><p>2019-01-01<br>在整个阅读的过程中，主人公默尔索一直给我这种感觉：无所谓，都行。母亲逝世后，默尔索并没有如别人一般表现痛苦难受，玛丽问他是否想要结婚时，他回答结不结都行，当无意枪杀阿拉伯人时，也没有急于为自己辩护，在将要执行死刑时，被一直逼问是否信仰上帝。</p>
<p>默尔索一切的举动在常人眼里就是不道德、政治不正确。在审判默尔索的罪行时，人们更多的在批判审视默尔索，任何的举动都要以世人道德标准来评判，不在乎事实过程，一遍遍的分析默尔索的动机，本是一个可以从轻处罚的案件，却最终以荒诞的结局来收场。</p>
<h1 id="霍乱时期的爱情"><a href="#霍乱时期的爱情" class="headerlink" title="霍乱时期的爱情"></a>霍乱时期的爱情</h1><p>2019-03<br>一直以来都是用 kindle 在上下班坐公交地铁的时间来读书，《霍乱时期的爱情》买的实体书来看，所以进度明显比用 kindle 慢了许多，看起来也断断续续的，读完不是很满意，以后有时间再二刷写感受吧。</p>
<h1 id="玛格丽特小镇"><a href="#玛格丽特小镇" class="headerlink" title="玛格丽特小镇"></a>玛格丽特小镇</h1><p>2019-04-03<br>这本书的名字和之前做的一种饼干（玛格丽特饼干）名字几乎一样，就勾起了我的好奇心，用比较短的时间读完，读的过程中觉得整个叙述缺乏逻辑条理，随意切换场景，但好像正是这种平淡的叙述方式，读起来反而更加随心，更加吸引人。</p>
<blockquote>
<p>某种程度上，你在一个地方认识的人，定义了那个地方对于你的意义。<br>爱情就像一个学步的贪婪孩子，只认得两个字，那就是”我的”。<br>对初恋的执恋从来都跟对象无关，都是人们对自己的怀念。<br>我跑到生命尽头看了看， 看到我们果然白头偕老了。<br>有时候，我们会言过其实。有时候，我们会说一些不是那么真实的话，暗自希望说出来后即会成真。</p>
</blockquote>
<p>他们在小镇上碰到五个玛格丽特，有天真可爱的小孩子梅，青春叛逆的米亚，忧伤的玛吉，怪异的玛琪，还有耳聋的的老玛格丽特。而这些都是不同心静，不同时期的玛格丽特。<br>就像是每个人都会有多方面的自己，每个时期都可能变成不同的人，而爱一个人就要能接受她的全部，无论美丑琐碎。<br>看完后看评价才发现是《岛上书店》作者的新作，准备再重温一遍《岛上书店》。</p>
<p>读书的时候有一种状态会让人特别愉悦，就是读着读着，一些文字就会让心里波动一下，有时是温暖，有时是揪心，有时是绝妙，有时是感动，就像是在经历不同的事情，寻找内心的自己，这大概就是读书的乐趣吧。</p>
<h1 id="岛上书店"><a href="#岛上书店" class="headerlink" title="岛上书店"></a>岛上书店</h1><p>2019-04-18<br>二刷《岛上书店》，看之前试着回忆一下故事情节，发现几乎想不起来了… 再刷的过程中，细节慢慢浮现出来。<br>（当时只记录了上面的话，想着之后补上后续的读书笔记，然而就是因为没及时写，之后想补已经忘的差不多了，我这可怕的记忆力）</p>
<h1 id="挪威的森林"><a href="#挪威的森林" class="headerlink" title="挪威的森林"></a>挪威的森林</h1><p>2019-04-28<br>大学的时候急于拓宽自己的知识面，囫囵吞枣读了一些书，有的是为了读而读，读书时急于看到直给的东西，大多数都体会不到读书的乐趣，《挪威的森林》就属于这种，迷迷糊糊读到一半可能就换下一本了。再次读虽说还是觉得迷糊，但也是有耐心从头看到尾。</p>
<p>读完想了想这到底是一部什么样的小说，气氛低沉、伤感、平静。直子自从姐姐的死、木月的自杀之后陷入抑郁症的痛苦中，渡边几乎是她唯一的希望，然而她最终还是没能拯救自己。初美是一个优秀完美的女性，永泽拈花惹草、放荡不羁的性格以及价值观，让他意识到自己配不上初美，甚至觉得和初美在一起也违背自己的价值观，最终通过伤害初美让初美主动离开，而初美最后的自杀也是让人很惋惜。绿子几乎是唯一一个热情单纯的人，一道光一样的存在，渡边一直心系直子，绿子的所有举动渡边都没放在心上，包括渡边搬家忘记告诉绿子，绿子换发型没注意到，这就是不爱吧，因为不爱所以不关注。</p>
<h1 id="傲慢与偏见"><a href="#傲慢与偏见" class="headerlink" title="傲慢与偏见"></a>傲慢与偏见</h1><p>2019-12<br>某天周末想看电影放松一下，随意打开两个高分电影，一眼就被这部电影的高清开场吸引了，电影里唯美的景色，光看背景都是一种享受，看到伊丽莎白与达西之间产生误会冲突也会跟着揪心，可能也是对美好爱情的向往，在看这部电影时觉得格外心动。</p>
<p>记得之前看完&lt;&lt;被嫌弃的松子的一生&gt;&gt;之后，想再去看电影回顾一下，发现电影破坏了当初看小说的内心想象，所以之后电影和小说基本都会二选一，《傲慢与偏见》是我看完电影强烈想要去读原著想要了解人物当下内心感受的书，并且在一周内很快读完。电影整体节奏比较快，在读完一半小说之后忍不住又去再看了一遍电影，很多场景也有了不一样的感受。</p>
<p>读完这本书之后想到，我对这本书又何尝不是一种偏见呢，很早就知道了这本书但从没想主动去看，甚至见到这本书也自然而然绕过，内心觉得名著都是晦涩难懂的，可能名著是和『学习』挂钩的，『学习』这个词就给人一种压力，总觉得任何需要『学习』的知识都不容易理解，都不是自然而然可以习到或得到，都需要克服一些条件，即使收获比较大过程也不是享受的。我这种潜意识不仅在是读书，在平时工作生活中也有很大的影响，即使现在意识到了也很难抹平现在及以后的影响，慢慢来吧。</p>
<p>今年下半年换了份工作，感受到了未有的压力和焦虑，更多的感受到交流沟通的困难以及思维方式不同带来的认知差异，度过了几个月满脑子都是工作没有生活乐趣的生活，与此同时读书时间也少了很多，《约翰克里斯朵夫》《漫长的告别》等都还是未完成的状态，希望2020年工作上能顺心点，生活上能尝试更多的可能性，阅读更自然的成为生活的一部分。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/10/webpack-analyze-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ruirui">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ruirui's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/10/webpack-analyze-1/" itemprop="url">Webpack 分析系列-打包后 js 文件分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-10T13:29:14+08:00">2019-11-10</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>网上的 webpack 分析系列文章已经很多了，但从自己理解的角度出发，进行记录和梳理，是一个知识重新构建的过程，更加有利于消化吸收。此次把 webpack 当作一个系列来记录，希望从整体的体系出发，加深对 webpack 的理解。<br>首先从 webpack 打包生成的文件进行简单分析。</p>
<p><a href="https://github.com/seasonrui/webpack-analyze/tree/master/overview" target="_blank" rel="noopener">本文代码地址</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> B = <span class="string">'b'</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">import</span> B <span class="keyword">from</span> <span class="string">'./b'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(B);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> A = <span class="string">'a'</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; A &#125; <span class="keyword">from</span> <span class="string">'./a'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(A);</span><br></pre></td></tr></table></figure>
<p>执行 <code>npm run build</code>(webpack –mode development) 生成 main.js 如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>) </span>&#123; <span class="comment">// webpackBootstrap</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load entry module and return exports</span></span><br><span class="line">    <span class="keyword">return</span> __webpack_require__(__webpack_require__.s = <span class="string">"./src/index.js"</span>);</span><br><span class="line">&#125;)(</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="string">"./src/a.js"</span>: (<span class="function"><span class="keyword">function</span>(<span class="params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;&#125;,</span><br><span class="line">    <span class="string">"./src/b.js"</span>: (<span class="function"><span class="keyword">function</span>(<span class="params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;&#125;,</span><br><span class="line">    <span class="string">"./src/index.js"</span>: (<span class="function"><span class="keyword">function</span>(<span class="params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>可以看到，打包出来的是一个立即执行函数，参数是一个 key-value 的对象，key 是引入文件的路径，value 是对应的文件生成的模块化函数，立即执行函数返回一个从入口文件开始执行的<code>__webpack_require__</code>函数，关键就是<code>__webpack_require__</code>函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The require function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if module is in cache</span></span><br><span class="line">    <span class="keyword">if</span>(installedModules[moduleId]) &#123;</span><br><span class="line">        <span class="keyword">return</span> installedModules[moduleId].exports;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Create a new module (and put it into the cache)</span></span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">module</span> = installedModules[moduleId] = &#123;</span><br><span class="line">        i: moduleId,</span><br><span class="line">        l: <span class="literal">false</span>,</span><br><span class="line">        exports: &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute the module function</span></span><br><span class="line">    modules[moduleId].call(<span class="built_in">module</span>.exports, <span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Flag the module as loaded</span></span><br><span class="line">    <span class="built_in">module</span>.l = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the exports of the module</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>__webpack_require__</code> 根据 moduleId 来执行每一个 module 函数，当 installedModules 缓存中有该模块的对象，也就是该模块已经加载过，则从缓存中去取该对象的 exports，否则创建一个新的 module 对象执行 module 函数，module 对象有三个属性，i 表示 moduleId , l 表示模块是否已经加载过，exports 表示 module 的导出内容。通过 call 方法调用 module 的执行函数，执行函数的 this 指向 module.exports，后面三个是传入该函数的参数，<code>__webpack_require__</code>函数最后返回 module.exports。</p>
<p>回到最开始的立即执行函数，执行<code>__webpack_require__(__webpack_require__.s = &quot;./src/index.js&quot;)</code>，对应的入口文件的 module 函数如下。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***/</span> <span class="string">"./src/index.js"</span>:</span><br><span class="line"><span class="comment">/*!**********************!*\</span></span><br><span class="line"><span class="comment">  !*** ./src/index.js ***!</span></span><br><span class="line"><span class="comment">  \**********************/</span></span><br><span class="line"><span class="comment">/*! no exports provided */</span></span><br><span class="line"><span class="comment">/***/</span> (<span class="function"><span class="keyword">function</span>(<span class="params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">"__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _a__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./a */ \"./src/a.js\");\n\nconsole.log(_a__WEBPACK_IMPORTED_MODULE_0__[\"A\"]);\n\n//# sourceURL=webpack:///./src/index.js?"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/***/</span> &#125;)</span><br></pre></td></tr></table></figure></p>
<p>把无关的注释都删掉，取出 eval 里的代码（eval 函数可执行其中的的 JavaScript 代码）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"./src/index.js"</span>:</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">    "use strict"</span>;</span><br><span class="line">    __webpack_require__.r(__webpack_exports__);</span><br><span class="line">    <span class="keyword">var</span> _a__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(<span class="string">"./src/a.js"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(_a__WEBPACK_IMPORTED_MODULE_0__[<span class="string">"A"</span>]);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"./src/a.js"</span>:</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">    "use strict"</span>;</span><br><span class="line">    __webpack_require__.r(__webpack_exports__);</span><br><span class="line">    __webpack_require__.d(__webpack_exports__, <span class="string">"A"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> A; &#125;);</span><br><span class="line">    <span class="keyword">var</span> _b__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(<span class="string">"./src/b.js"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(_b__WEBPACK_IMPORTED_MODULE_0__[<span class="string">"default"</span>]);</span><br><span class="line">    <span class="keyword">const</span> A = <span class="string">'a'</span>;</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"./src/b.js"</span>:</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span>;</span><br><span class="line">    __webpack_require__.r(__webpack_exports__);</span><br><span class="line">    __webpack_exports__[<span class="string">"default"</span>] = (B = <span class="string">'b'</span>);</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure>
<p>这样拆开来分析就比较一目了然了，从这三个文件可以看出，在执行模块时除了执行本身模块内容外，还会执行<code>__webpack_require__.r</code>,<code>__webpack_require__.d</code>等函数，从打包生成的 main.js 的立即执行函数中找这几个函数的定义</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define __esModule on exports</span></span><br><span class="line">__webpack_require__.r = <span class="function"><span class="keyword">function</span>(<span class="params">exports</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">Symbol</span> !== <span class="string">'undefined'</span> &amp;&amp; <span class="built_in">Symbol</span>.toStringTag) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(exports, <span class="built_in">Symbol</span>.toStringTag, &#123; <span class="attr">value</span>: <span class="string">'Module'</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(exports, <span class="string">'__esModule'</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// define getter function for harmony exports</span></span><br><span class="line">__webpack_require__.d = <span class="function"><span class="keyword">function</span>(<span class="params">exports, name, getter</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!__webpack_require__.o(exports, name)) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(exports, name, &#123; <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">get</span>: getter &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Object.prototype.hasOwnProperty.call</span></span><br><span class="line">__webpack_require__.o = <span class="function"><span class="keyword">function</span>(<span class="params">object, property</span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.hasOwnProperty.call(object, property); &#125;;</span><br></pre></td></tr></table></figure>
<p><code>__webpack_require__.r</code> 函数是 webpack 针对不同模块加了不同的标记处理，因为是 import 引入的，给 exports 对象加上ES harmony规范的标记。<br>执行<code>__webpack_require__.d(__webpack_exports__, &quot;A&quot;, function() { return A; });</code> 实际上就是生成<code>__webpack_exports__.A = A;</code></p>
<p>从入口的 index.js 分析，首先对 index.js 进行了 esModule 的模块化标记，因为 index.js 引入了 a.js，接着对 a 模块执行<code>__webpack_require__</code>, 打印出 a 模块的执行结果。a 模块同样进行了 esModule 标记，并且生成了 <code>module.exports.A = A</code> ，将 A 变量导出，index.js 打印出 A 的结果。因为 b.js 使用的是<code>export default</code>，webpack 处理后，会在 module.exports 中增加一个 default 属性。</p>
<p>至此，我们看到，webpack 的输出文件，将各个模块以参数的形式传递给 IIFE 函数，从入口文件开始递归解析依赖，在解析的过程中，分别对不同的模块进行处理，返回模块的exports。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/17/react-immutable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ruirui">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ruirui's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/17/react-immutable/" itemprop="url">React 数据更新 与 Immutable</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-17T10:03:30+08:00">2019-09-17</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>8月份入职新公司，刚入职就参与了一个迭代频繁的项目，也开始真正使用 React 做业务项目。接手的一个模块需要处理深层数据，在这过程中也爬了很多坑，终于搞明白了 React 的数据更新机制。在此做一个总结。</p>
<h2 id="React-渲染"><a href="#React-渲染" class="headerlink" title="React 渲染"></a>React 渲染</h2><p>最开始熟悉项目的时候发现，在组件 render 函数的地方打印 <code>console.log</code>，会打印很多次，也就是一个组件会调用很多次 render，这样肯定会频繁的触发 React 的 diff 比较进行 patch 更新，这就很奇怪了，因为 Vue 里，render 函数只有在初始化和依赖的数据发生变化时才会触发，难道 React 有什么不同？于是开始研究 React 的渲染机制，什么时候会进行 render 呢？来一张官网的生命周期图。</p>
<p><img src="lifecycle.jpg" alt="lifecycle"></p>
<p>可以看到，除了第一次挂载会初始化进行一次渲染外，在 props 或 state 有任何一个改变时，会根据 <code>shouldComponentUpdate</code> 值来判断是否进行 render，普通的 component 的 <code>shouldComponentUpdate</code> 默认会返回 true ，可以通过手写 <code>shouldComponentUpdate</code> 判断是否真正需要重新渲染来提高性能，也可以通过继承 <code>React.PureComponent</code> 来实现，<code>PureComponent</code> 内部进行浅比较（shallowEqual），比较前后两次 state 和 props 是否相等（如果是值类型，就进行值比较，引用类型比较地址是否相同），如果相等就不去更新。 这就会引入一个问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListOfWords</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;&#123;this.props.words.join(',')&#125;&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordAdder</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      words: [<span class="string">'marklar'</span>]</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="comment">// 这部分代码很糟，而且还有 bug</span></span><br><span class="line">    <span class="keyword">const</span> words = <span class="keyword">this</span>.state.words;</span><br><span class="line">    words.push(<span class="string">'marklar'</span>);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">words</span>: words&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125; /&gt;</span><br><span class="line">        &lt;ListOfWords words=&#123;<span class="keyword">this</span>.state.words&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>点击按钮时，会通过 <code>push</code> 方法添加一个单词，words 的引用地址没变，而 <code>PureComponent</code> 会进行浅比较，<code>shoulComponentUpdate</code> 会返回 <code>false</code> ， 所以 <code>ListOfWords</code> 不会被重新渲染，这就是可变数据带来的问题。</p>
<h2 id="不可变数据"><a href="#不可变数据" class="headerlink" title="不可变数据"></a>不可变数据</h2><p>所以避免该问题的方式就是使用不可变数据，不可变数据就是一旦对象创建就不可再修改，当需要改变时不可直接修改状态，需要通过生成一个新对象的方式来修改。</p>
<p>上面例子的的解决方式就是不去直接修改 props 或者 state，而是通过生成新的引用来替换</p>
<ul>
<li>原生写法 <code>Object.assign()</code>、<code>concat</code> 等</li>
<li>ES6 扩展运算符</li>
</ul>
<p>上述两种方法是处理简单对象常用的方式，<code>Object.assign</code> 和 <code>对象扩展运算符</code> 都是对对象做了一个浅拷贝，所以如果在深层嵌套对象里，要去改变嵌套对象里面的值，使用上述两种方式并达不到预期的效果，借用 <a href="https://codesandbox.io/s/j13mmv8z5" target="_blank" rel="noopener">这个例子</a> 来看<strong>(一定要点开看啊！)</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">state = &#123;</span><br><span class="line">    user: &#123;</span><br><span class="line">      id: <span class="number">1</span>,</span><br><span class="line">      name: <span class="string">"Cory"</span>,</span><br><span class="line">      address: &#123;</span><br><span class="line">        city: <span class="string">"Kansas City"</span>,</span><br><span class="line">        state: <span class="string">"Kansas"</span>,</span><br><span class="line">        modified: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString()  <span class="comment">// 现在需要改变这个值</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>user 是个深层对象，需要改变 modified 的值，对 user 的引用有三种组件，分别是 A 组件(React.Component)、B 组件(React.PureComponent)、C组件(React.Component，里面嵌套了Address 组件(React.PureComponent))。对 modified 的修改分别采用三种方式，看对应的渲染情况。</p>
<ol>
<li><strong>Mutate 直接修改</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutate = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> user = <span class="keyword">this</span>.state.user; <span class="comment">// still mutating user since just a ref!</span></span><br><span class="line">   user.address.modified = <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString();</span><br><span class="line">   <span class="keyword">this</span>.setState(&#123; user &#125;);</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 组件：因为 shouldComponent 都会返回 true，会重新渲染。</li>
<li>B 组件：因为 user 的引用地址没有变化, B 组件使用 PureComponent，会进行浅比较，所以B组件不会重新渲染。</li>
<li>C 组件：同 A 组件会重新渲染，但是因为 address 的引用地址没变, Address 组件使用的 PureComponent, 所以 Address 不会重新渲染。</li>
</ul>
<ol start="2">
<li><strong>Shallow 浅拷贝</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shallow = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> user = &#123; ...this.state.user &#125;;</span><br><span class="line">  user.address.modified = <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString();</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; user &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 组件：重新渲染。</li>
<li>B 组件：重新渲染。</li>
<li>C 组件：同 A 组件会重新渲染，但是因为 address 的引用地址没变, Address 组件使用的 PureComponent, 所以 Address 不会重新渲染。</li>
</ul>
<ol start="3">
<li><strong>Deep 深拷贝</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">deep = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> user = &#123;</span><br><span class="line">    ...this.state.user,</span><br><span class="line">    address: &#123; ...this.state.user.address &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  user.address.modified = <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString();</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; user &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>A 组件：重新渲染。</li>
<li>B 组件：重新渲染。</li>
<li>C 组件：重新渲染，子组件 Address 因为 address 引用地址改变也会重新渲染。</li>
</ul>
<p>不提倡使用深拷贝的方式，他的代价是昂贵的，并且深拷贝会导致 React 进行不必要的渲染，因为嵌套的每个对象引用地址都改变了，引用这些数据的组件全部都会重新渲染。对于深层对象的处理，<strong>我们要做的只是拷贝已经改变的对象</strong>。有一些库例如 <a href="https://github.com/kolodny/immutability-helper" target="_blank" rel="noopener">immutability-helper</a>、<a href="https://github.com/immerjs/immer" target="_blank" rel="noopener">immer</a>、<a href="https://github.com/immutable-js/immutable-js" target="_blank" rel="noopener">immutable-js</a> 等都可以实现不可变数据结构。</p>
<h2 id="immutable-js"><a href="#immutable-js" class="headerlink" title="immutable.js"></a>immutable.js</h2><p>immutable.js 是 Facebook 推出的能让开发者建立不可变数据的函数库，内部实现了一套完整的<strong>持久化数据结构</strong>，也就是说，对数据的所有的更新操作最后都会生成一个新的数据结构，原有结构保持不变，这也意味着所有的数据都是不可变的，有了这个限制前提，更新操作就有了很多优化的空间，例如更新一个深层节点的数据， Immutable 的实现原理如下</p>
<p><img src="immutable.gif" alt="immutable"></p>
<p>当需要更新某个节点数据时，只需要顺着链路更新分支上的节点，尽可能的复用现有的节点，这样既提升了性能，也降低了内存开销，immutable 的这个特点也称为<strong>结构共享</strong>。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>除了上面说的渲染性能优化，因为 Redux 设计是以几个原则为优先的：状态可追踪，可重复，可维护，不可变数据也是 Redux 运行的基础，因为有了不可变数据，当 store 发生变化时，任何时候都能记录变化之前和变化之后的状态，方便计算 diff，平时开发调试用的 chrome 插件就是利用了此机制进行追踪。</p>
<h2 id="扁平化"><a href="#扁平化" class="headerlink" title="扁平化"></a>扁平化</h2><p>在项目开发中，我们应该尽可能的减少使用深层数据结构，尽量将 store 组织的扁平化和范式化，扁平化的意思是：只要不存在“实体下面再挂实体”的现象，应该就可以认为是扁平。</p>
<h2 id="React-与-Vue-在渲染上的不同"><a href="#React-与-Vue-在渲染上的不同" class="headerlink" title="React 与 Vue 在渲染上的不同"></a>React 与 Vue 在渲染上的不同</h2><ul>
<li>React 和 Redux 都提倡不可变性，更新需要维持不可变原则，Vue 不需要。</li>
<li>React 应用需要考虑优化机制，当某个组件发生变化时，会以该组件为根，重新渲染整个组件子树，所以需要尽可能的使用 PureComponent 和 shouldComponentUpdate 方法，同时使用不可变数据结构来使的组件更容易被优化。</li>
<li>Vue 采用依赖追踪机制，能精确的知道哪些组件需要重新渲染，不会存在过渡重渲染的性能问题，默认就是优化状态。<br>React 渲染功能依赖 jsx，Vue 支持 jsx，但更多的使用 template 模板，这两个在性能上也有点区别，jsx 属于动态渲染，所有的 DOM 节点都是动态生成的，所以页面节点越多，DOM开销就会越大，并且无法根据初始状态进行优化，template在初始编译时，会根据节点类型找出静态节点并进行标记，数据变化时可以跳过这些静态节点的对比，避免进行无意义的 diff。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/14/javascript-object-oriented/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ruirui">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ruirui's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/14/javascript-object-oriented/" itemprop="url">Javascript 面向对象、原型与继承</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-14T12:59:51+08:00">2019-07-14</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近面试，有被问到关于原型链及继承的知识，于是系统的整理一下。</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>编程语言的对象，成功的流派使用”类”的方式来描述对象。Javascript早期用『原型』的方式来描述对象。</p>
<h3 id="对象的特点"><a href="#对象的特点" class="headerlink" title="对象的特点"></a>对象的特点</h3><ul>
<li>对象具有唯一标识性：即使两个完全一样的对象，也并非同一个对象。</li>
<li>对象有状态：同一个对象可能处于不同的状态之下。</li>
<li>对象有行为：对象的状态可能因为它的行为产生变迁。</li>
</ul>
<p>唯一标识性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var o1 = &#123;a: 1&#125;;</span><br><span class="line">var o1 = &#123;a: 1&#125;;</span><br><span class="line">console.log(o1 == 02); // false</span><br></pre></td></tr></table></figure></p>
<p>状态和行为特征在 javascript 中统一抽象为”属性”。<br>除对象基本特征外，javascript 的对象具体高度的动态性，因为 javascript 赋予了使用者在运行时为对象添改状态和行为的能力。也就是说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;a: 1&#125;;</span><br><span class="line">o.b = 2;</span><br><span class="line">console.log(o.a o.b); // 1 2</span><br></pre></td></tr></table></figure></p>
<p>可以在定义对象之后再去添加属性。<br>为了提高抽象能力，javascript 属性提供了<strong>数据属性</strong>和<strong>访问器属性（getter/setter）</strong> 两类。</p>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>Javascript 通过 new 关键字来创建一个对象，new 关键字做了什么？</p>
<ul>
<li>创建一个对象</li>
<li>将对象的原型（__proto__）指向构造函数的原型（prototype属性）</li>
<li>将构造函数内部的 this 指向这个空对象，执行构造函数的逻辑</li>
<li>如果构造函数内部没有返回对象，则返回创建的对象。</li>
</ul>
<p>具体实现为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objectFactory</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出第一个参数（构造器），并从参数中删除。</span></span><br><span class="line">    <span class="keyword">const</span> Constructor = args.shift();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个空对象，并将空对象的_proto_属性指向构造函数的 prototype 属性</span></span><br><span class="line">    <span class="comment">// 不建议直接操作_proto_属性（obj.__proto__ = Constructor.prototype）</span></span><br><span class="line">    <span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(<span class="keyword">constructor</span>.prototype);</span><br><span class="line"></span><br><span class="line">    // 执行构造器， 将构造函数内的 this 指向为 obj</span><br><span class="line">    var result = Constructor.apply(obj, args); </span><br><span class="line"></span><br><span class="line">    // 如果构造器返回对象则返回这个对象，否则返回新建的对象。</span><br><span class="line">    return (typeof result === 'object' &amp;&amp; result != null) ? result : obj; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 使用方式</span><br><span class="line">function Person(name) &#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> objectFactory(Person, <span class="string">'season'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person)</span><br></pre></td></tr></table></figure></p>
<h2 id="原型及原型链"><a href="#原型及原型链" class="headerlink" title="原型及原型链"></a>原型及原型链</h2><p>用 &lt;<javascript 高级程序设计>&gt;中的图来表示<br><img src="prototype.png" alt="prototype"><br>总结下来：</javascript></p>
<ul>
<li>每个函数都有一个 prototype 指向其原型（构造函数.prototype === 原型）</li>
<li>每个原型的 constructor 属性都指向该构造函数（原型.constructor === 构造函数）</li>
<li>每个实例（对象）都有一个 __proto__ 属性指向该构造函数的原型（实例.__proto__ === 原型）</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p>关键点：子类原型继承父类的实例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'child1'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child1.getName()); <span class="comment">// child1</span></span><br><span class="line">child1.list.push(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child(<span class="string">'child2'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child2.getName()); <span class="comment">// child2</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.list); <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></p>
<p>缺点：</p>
<ul>
<li>当父类构造函数有引用类型时，该引用类型会被所有子类所共享（修改 child1 的 list 属性时，chil2 也会修改）</li>
<li>创建子类时，不能向父类构造函数传递参数</li>
</ul>
<h3 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h3><p>关键点：在子类构造函数内调用父类构造函数方法，可以向父类传递参数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Parent.call(<span class="keyword">this</span>, args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>, args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'child1'</span>, <span class="string">'parent1'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child1.getName()); <span class="comment">// Uncaught TypeError: child1.getName is not a function</span></span><br><span class="line">child1.list.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child1.list) <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child(<span class="string">'child2'</span>, <span class="string">'parent2'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child2.list); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></p>
<p>可以向父类传递参数，也解决了上述共享父类引用类型的问题<br>缺点：不能继承父类原型上的方法。（上述<code>child1.getName()</code>获取不到）</p>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>关键点：结合前面两种方式，使用<strong>原型链</strong>实现对原型属性和方法的继承，通过借用<strong>构造函数</strong>实现对实例属性的继承。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">args1, args2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">this</span>.args1 = args1</span><br><span class="line">    Parent.call(<span class="keyword">this</span>, args2)</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line">Child.prototype.constrcutor = Child</span><br></pre></td></tr></table></figure></p>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>, args)</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line">Child.prototype.constrcutor = Child;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'child1'</span>, <span class="string">'parent1'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child1.getName()); <span class="comment">// parent1</span></span><br><span class="line">child1.list.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child1.list) <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child(<span class="string">'child2'</span>, <span class="string">'parent2'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child2.list); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>缺点：会调用两次父类构造函数，<code>Parent.call(this, args)</code>会调用一次，<code>Child.prototype = new Parent();</code>还会调用一次。</p>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>原型式继承<strong>没有严格意义上的构造函数</strong>，他的想法主要是<strong>借助原型可以基于已有的对象创建新对象</strong>，也就是一个对象以另一个对象为基础，根据需求传入自己的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 object 内部先创建了一个临时构造函数，将传入的对象作为构造函数的原型，返回临时构造函数的实例。<br>ECMAScript5 通过加入<code>Object.create()</code>方法规范化了原型式继承。<br>示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> parent = &#123;</span><br><span class="line">    name: <span class="string">'parent'</span>,</span><br><span class="line">    list: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = object(parent);</span><br><span class="line">child1.name = <span class="string">"child1"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(child1.name); <span class="comment">// 'child1'</span></span><br><span class="line">child1.list.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child1.list); <span class="comment">//  [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = object(parent);</span><br><span class="line"><span class="built_in">console</span>.log(child2.list); <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到用 object 的方式，父类的引用类型共享的问题还是存在，因为 object 方法其实是做了一层浅拷贝，所以父类的引用类型始终会共享。<br>在不考虑构造函数，只想基于一个对象生成另一个对象的情况下，原型式继承是比较适用的。</p>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>和原型式继承类似，也是通过创建一个封装继承过程的函数，在函数内部以某种方式增强对象，最后返回对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = object(original);</span><br><span class="line">    clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">// 以某种方式来增强这个对象，给该对象增加一个 sayHi 方法</span></span><br><span class="line">        alert(<span class="string">"hi"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同上面原型式继承类似，在不考虑构造函数的情况，寄生式继承是一种有用的模式。</p>
<h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>因为组合式继承会调用两次构造函数，寄生组合式继承通过<strong>寄生式继承来继承超类的原型</strong>，避免在指定子类原型的时候调用父类构造函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = object(superType.prototype);</span><br><span class="line">    prototype.constructor = subType;</span><br><span class="line">    subType.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>, args);  <span class="comment">// 通过构造函数来继承属性</span></span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(Child, Parent); <span class="comment">// 通过寄生式继承来继承父类的原型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'child1'</span>, <span class="string">'parent1'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child1.getName()); <span class="comment">// parent1</span></span><br><span class="line">child1.list.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child1.list) <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child(<span class="string">'child2'</span>, <span class="string">'parent2'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child2.list); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></p>
<p>使用 Object.create() 替代上述的 object();<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype);</span><br><span class="line">Child.prototype.constructor = Child;</span><br></pre></td></tr></table></figure></p>
<h3 id="ES6-继承"><a href="#ES6-继承" class="headerlink" title="ES6 继承"></a>ES6 继承</h3><p>ES6 通过 extend 实现继承。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">'parent'</span>;</span><br><span class="line">        <span class="keyword">this</span>.list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">super</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="built_in">console</span>.log(child1.name); <span class="comment">// parent</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.getName())  <span class="comment">// parent</span></span><br><span class="line">child1.list.push(<span class="number">4</span>)  <span class="comment">// parent</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.list)  <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="built_in">console</span>.log(child2.name); <span class="comment">// parent</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.getName())  <span class="comment">// parent</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.list)  <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></p>
<p>区别</p>
<ul>
<li>ES5 实现继承的方式是：先构造子类的实例对象 this，再将父类方法添加进去（parent.apply(this)）。</li>
<li>ES6 通过 extend 实现继承，先将父类的属性和方法添加到 this 上（先调用 super 方法），再调用子类的构造函数修改 this</li>
</ul>
<p>ES6 继承实际上是 ES5 原型的语法糖，将上述继承通过 <a href="https://babeljs.io/repl" target="_blank" rel="noopener">babel 在线编译工具</a>进行转换，得到<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... 省略一些方法定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_inherits</span>(<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 父类必须是函数并且不能为null</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> superClass !== <span class="string">"function"</span> &amp;&amp; superClass !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Super expression must either be null or a function"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 通过Object.create实现继承，第二个参数用来修复子类的 constructor</span></span><br><span class="line">    subClass.prototype = <span class="built_in">Object</span>.create(superClass &amp;&amp; superClass.prototype, &#123;</span><br><span class="line">        <span class="keyword">constructor</span>: &#123;</span><br><span class="line">            value: subClass,</span><br><span class="line">            writable: <span class="literal">true</span>,</span><br><span class="line">            configurable: <span class="literal">true</span> </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 设置子类的 __proto__ 属性指向父类</span></span><br><span class="line">    <span class="keyword">if</span> (superClass) </span><br><span class="line">        _setPrototypeOf(subClass, superClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_setPrototypeOf</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">    _setPrototypeOf = <span class="built_in">Object</span>.setPrototypeOf || <span class="function"><span class="keyword">function</span> <span class="title">_setPrototypeOf</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">        o.__proto__ = p; <span class="keyword">return</span> o;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> _setPrototypeOf(o, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 两个参数，一个参数是指向子类实例的this，另一个参数是 调用父类构造函数的返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_possibleConstructorReturn</span>(<span class="params">self, call</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果父类返回的是对象或者函数，则返回 父类构造函数生成的this（Parent.call(this)），否则返回子类的this</span></span><br><span class="line">    <span class="keyword">if</span> (call &amp;&amp; (_typeof(call) === <span class="string">"object"</span> || <span class="keyword">typeof</span> call === <span class="string">"function"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> call; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> _assertThisInitialized(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_getPrototypeOf</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    _getPrototypeOf = <span class="built_in">Object</span>.setPrototypeOf ? <span class="built_in">Object</span>.getPrototypeOf : <span class="function"><span class="keyword">function</span> <span class="title">_getPrototypeOf</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o.__proto__ || <span class="built_in">Object</span>.getPrototypeOf(o); </span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="keyword">return</span> _getPrototypeOf(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Parent =</span><br><span class="line"><span class="comment">/*#__PURE__*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    _classCallCheck(<span class="keyword">this</span>, Parent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'parent'</span>;</span><br><span class="line">    <span class="keyword">this</span>.list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _createClass(Parent, [&#123;</span><br><span class="line">    key: <span class="string">"getName"</span>,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Parent;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Child =</span><br><span class="line"><span class="comment">/*#__PURE__*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">_Parent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通过 Object.create 实现继承</span></span><br><span class="line">  _inherits(Child, _Parent);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 确保类是通过 new 作为构造函数调用而不是直接调用</span></span><br><span class="line">    _classCallCheck(<span class="keyword">this</span>, Child);</span><br><span class="line">    <span class="comment">// _getPrototypeOf(Child) 返回 子类的原型（父类构造函数），通过子类 this 执行父类构造函数的方法</span></span><br><span class="line">    <span class="keyword">return</span> _possibleConstructorReturn(<span class="keyword">this</span>, _getPrototypeOf(Child).call(<span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Child;</span><br><span class="line">&#125;(Parent);</span><br></pre></td></tr></table></figure></p>
<p>简化：子类首先执行<code>_inherits(Child, _Parent);</code>，内部通过<code>Object.create</code>建立子类与父类原型链关系，然后再通过调用<code>Parent.call(this)</code>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/04/install-node-and-npm-on-linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ruirui">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ruirui's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/04/install-node-and-npm-on-linux/" itemprop="url">『转』Linux 安装 node 和 npm</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-04T13:35:27+08:00">2019-06-04</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文来自<a href="https://jpanj.com/2019/install-node-and-npm-on-linux/" target="_blank" rel="noopener">https://jpanj.com/2019/install-node-and-npm-on-linux/</a></p>
<p>网上介绍 <a href="https://nodejs.org" target="_blank" rel="noopener">Node</a> 如何安装的文章数不胜数，但我还是决定自己写一篇记录一下，最主要的原因是网上的文章比较混乱，有的建议通过包管理工具安装，还有的让一步步编译源码来安装。</p>
<p>通过包管理工具安装的通常版本不会太新，通过源码安装的方式非常麻烦，还需要提前安装 <code>gcc</code> 之类的，只有极少部分良心博主介绍了通过二进制文件直接安装的方式，但操作上都不是特别规范。</p>
<p>网上已有的文章还有一个很严重的问题，就是没有考虑国内的网络环境，不管从 Node 官方下载源码包还是二进制包，都巨慢无比，所以我把已经下载好的包放在 CDN 上供自己和大家之后使用。同时我还提供了其他常用软件的安装包，如 Nginx，Java，Neo4j 等等，后边有机会列个清单出来，并准备长期维护更新版本。</p>
<hr>
<p>下边进入正题：</p>
<blockquote>
<p>我推荐以下操作在 <code>/opt</code> 目录下进行</p>
</blockquote>
<h4 id="下载压缩包"><a href="#下载压缩包" class="headerlink" title="下载压缩包"></a>下载压缩包</h4><p><code>wget http://developer.jpanj.com/node-v10.15.3-linux-x64.tar.xz</code></p>
<h4 id="解压为-tar-包"><a href="#解压为-tar-包" class="headerlink" title="解压为 tar 包"></a>解压为 tar 包</h4><p><code>xz -d node-v10.15.3-linux-x64.tar.xz</code></p>
<h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><p><code>tar -xvf node-v10.15.3-linux-x64.tar</code></p>
<h4 id="当前目录下软链一个-node-目录出来"><a href="#当前目录下软链一个-node-目录出来" class="headerlink" title="当前目录下软链一个 node 目录出来"></a>当前目录下软链一个 <code>node</code> 目录出来</h4><blockquote>
<p>这样做的好处是，未来升级版本非常方便，只需要更新这个软链就行</p>
</blockquote>
<p> <code>ln -s ./node-v10.15.3-linux-x64 ./node</code></p>
<h4 id="通过软链接，将可执行程序放入系统环境变量的路径中"><a href="#通过软链接，将可执行程序放入系统环境变量的路径中" class="headerlink" title="通过软链接，将可执行程序放入系统环境变量的路径中"></a>通过软链接，将可执行程序放入系统环境变量的路径中</h4><ul>
<li>查看当前系统中都有哪些环境变量路径</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br></pre></td></tr></table></figure>
<p>可以看到我的列表中有：</p>
<ul>
<li><code>/usr/local/bin</code></li>
<li><code>/usr/bin</code></li>
</ul>
<p>大家约定成俗逻辑是：</p>
<ul>
<li><code>/usr/bin</code>下面的都是系统预装的可执行程序，会随着系统升级而改变。</li>
<li><code>/usr/local/bin</code> 目录是给用户放置自己的可执行程序的地方</li>
</ul>
<p>所以我推荐将软链放在 <code>/usr/local/bin</code> 目录下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s /opt/node/bin/node /usr/local/bin/node</span><br><span class="line">ln -s /opt/node/bin/npm /usr/local/bin/npm</span><br></pre></td></tr></table></figure>
<h4 id="检查是否安装成功"><a href="#检查是否安装成功" class="headerlink" title="检查是否安装成功"></a>检查是否安装成功</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@dc8 ~]# node -v</span><br><span class="line">v10.15.3</span><br><span class="line">[root@dc8 ~]# npm -v</span><br><span class="line">6.4.1</span><br></pre></td></tr></table></figure>
<h4 id="Done"><a href="#Done" class="headerlink" title="Done"></a>Done</h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/01/linux-command-record/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ruirui">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ruirui's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/01/linux-command-record/" itemprop="url">整理 Linux 常用命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-01T13:00:19+08:00">2019-06-01</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="查看某个端口号被什么程序占用并杀掉此进程："><a href="#查看某个端口号被什么程序占用并杀掉此进程：" class="headerlink" title="查看某个端口号被什么程序占用并杀掉此进程："></a>查看某个端口号被什么程序占用并杀掉此进程：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 查看某个端口的网络连接情况：`lsof -i:&lt;port&gt;`</span><br><span class="line">2. 根据返回结果中的进程号检查进程名称 `ps -ef | grep &lt;pid&gt;`</span><br><span class="line">3. 确认进程无误后杀掉该进程 `kill -9 &lt;pid&gt;`</span><br></pre></td></tr></table></figure>
<h3 id="scp-复制"><a href="#scp-复制" class="headerlink" title="scp 复制"></a>scp 复制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 文件</span><br><span class="line">scp local_file remote_username@remote_ip:remote_folder</span><br><span class="line"># 整个目录</span><br><span class="line">scp -r local_folder remote_username@remote_ip:remote_folder</span><br></pre></td></tr></table></figure>
<h3 id="查看某个ip的端口号是否连通"><a href="#查看某个ip的端口号是否连通" class="headerlink" title="查看某个ip的端口号是否连通"></a>查看某个ip的端口号是否连通</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet &lt;ip&gt; &lt;port&gt;</span><br></pre></td></tr></table></figure>
<h3 id="查看本机出口网络ip"><a href="#查看本机出口网络ip" class="headerlink" title="查看本机出口网络ip"></a>查看本机出口网络ip</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl ip.gs</span><br></pre></td></tr></table></figure>
<h3 id="压缩-tar-gz"><a href="#压缩-tar-gz" class="headerlink" title="压缩 tar.gz"></a>压缩 tar.gz</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zcvf xxx.tar.gz xxx/</span><br></pre></td></tr></table></figure>
<h3 id="解压-tar-gz"><a href="#解压-tar-gz" class="headerlink" title="解压 tar.gz"></a>解压 tar.gz</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf xxx.tar.gz</span><br></pre></td></tr></table></figure>
<h3 id="给一个文件添加可执行权限"><a href="#给一个文件添加可执行权限" class="headerlink" title="给一个文件添加可执行权限"></a>给一个文件添加可执行权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x xxx.sh</span><br></pre></td></tr></table></figure>
<h3 id="查看磁盘使用情况"><a href="#查看磁盘使用情况" class="headerlink" title="查看磁盘使用情况"></a>查看磁盘使用情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure>
<h3 id="查看内存使用情况"><a href="#查看内存使用情况" class="headerlink" title="查看内存使用情况"></a>查看内存使用情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -h</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">ruirui</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ruirui</span>

  

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.0.0</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.0"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
