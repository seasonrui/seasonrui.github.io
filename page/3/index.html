<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.0.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.0" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="tags">
<meta property="og:url" content="http://yoursite.com/tags/index.html">
<meta property="og:site_name" content="ruirui&#39;s blog">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2021-09-30T15:10:00.074Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="tags">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/tags/">





  <title>ruirui's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ruirui's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">ruirui's 备忘录</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/24/iframe-print/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ruirui">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ruirui's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/24/iframe-print/" itemprop="url">iframe 打印页面局部内容</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-24T17:49:42+08:00">2018-12-24</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>function printPartial(dom) {
      if (!dom) return;
      let copyDom = document.createElement(&apos;span&apos;);
      const styleDom = document.querySelectorAll(&apos;style, link, meta&apos;);
      Array.from(styleDom).forEach(item=&gt; {
        copyDom.appendChild(item.cloneNode(true));
      });
      copyDom.appendChild(dom.cloneNode(true));
      const htmlTemp = copyDom.innerHTML;
      copyDom = null;

      const iframeDom = document.createElement(&apos;iframe&apos;);
      const attrObj = {
        height: 0,
        width: 0,
        border: 0,
        wmode: &apos;Opaque&apos;,
      };
      const styleObj = {
        position: &apos;absolute&apos;,
        top: &apos;-999px&apos;,
        left: &apos;-999px&apos;,
      };
      Object.entries(attrObj).forEach(([key, value])=&gt; iframeDom.setAttribute(key, value));
      Object.entries(styleObj).forEach(([key, value])=&gt; iframeDom.style[key] = value);
      document.body.insertBefore(iframeDom, document.body.children[0]);
      var iframedocument = iframeDom.contentDocument;
      var iframeWindow = iframeDom.contentWindow;
      iframedocument.open();
      iframedocument.write(`&lt;!doctype html&gt;`);
      iframedocument.write(htmlTemp);
      iframedocument.close();
      iframeWindow.onload = function() {
        iframeWindow.focus();
        iframeWindow.print();
        document.body.removeChild(iframeDom);
      }
</code></pre><p> 注意：一定要在 iframe 里 windows 对象内容加载成功之后再去打印，iframe 的 print 方法是个阻塞的方法，类似 alert，会阻塞页面后续加载。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/20/implement-native-bind-function/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ruirui">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ruirui's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/20/implement-native-bind-function/" itemprop="url">实现原生 bind 函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-20T17:00:19+08:00">2018-12-20</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>bind() 方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind() 方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p>
</blockquote>
<p>看 MDN 上关于bind的用法如下：</p>
<ol>
<li>创建绑定函数<br> bind() 最简单的用法是创建一个函数，不管怎么调用，函数都有同样的 this 值。</li>
<li>偏函数<br> bind() 的另一个最简单的用法是使一个函数拥有预设的初始参数。只要将这些参数（如果有的话）作为bind()的参数写在 this 后面。<br> 例如：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addArguments</span>(<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg1 + arg2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result1 = addArguments(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 创建一个函数，它拥有预设的第一个参数</span></span><br><span class="line"><span class="keyword">var</span> addThirtySeven = addArguments.bind(<span class="literal">null</span>, <span class="number">37</span>); </span><br><span class="line"><span class="keyword">var</span> result2 = addThirtySeven(<span class="number">5</span>); <span class="comment">// 37 + 5 = 42</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上述37就是预设参数，函数 addThirtySeven 被调用时传入的参数会和之前的预设参数(37)一起传入 addThirtySeven 中。</p>
<ol start="3">
<li>作为构造函数使用的绑定函数。<br>返回的函数可以作为构造函数使用（也就是可以用 new 创建）<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.x + <span class="string">','</span> + <span class="keyword">this</span>.y; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> emptyObj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> YAxisPoint = Point.bind(emptyObj, <span class="number">0</span><span class="comment">/*x*/</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用 new 创建</span></span><br><span class="line"><span class="keyword">var</span> axisPoint = <span class="keyword">new</span> YAxisPoint(<span class="number">5</span>);</span><br><span class="line">axisPoint.toString(); <span class="comment">// '0, 5'</span></span><br><span class="line"></span><br><span class="line">axisPoint <span class="keyword">instanceof</span> Point; <span class="comment">// true</span></span><br><span class="line">axisPoint <span class="keyword">instanceof</span> YAxisPoint; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 仍然能作为一个普通函数来调用</span></span><br><span class="line">YAxisPoint(<span class="number">13</span>);</span><br><span class="line">emptyObj.x + <span class="string">','</span> + emptyObj.y;   <span class="comment">//  '0,13'</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>所以要是实现一个bind函数需要实现以下几个点：</p>
<ol>
<li>创建一个新函数，替换 this 并返回新函数。</li>
<li>可以设置预设参数并不会丢失预设参数。</li>
<li>可以当做构造函数调用且有正确的this指向。</li>
</ol>
<p>首先用猴子补丁<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="built_in">Function</span>.prototype.bind || bind;</span><br></pre></td></tr></table></figure></p>
<p>实现第一点：创建一个函数并返回新函数，将传入的第一个参数作为函数的 this 指向，使用 apply 或 call 来实现。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> self.apply(context, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>举例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// 指向 obj</span></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">   a: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">fn.bind(obj, <span class="number">1</span>, <span class="number">2</span>)(); <span class="comment">// []</span></span><br><span class="line">fn.bind(obj, <span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>); <span class="comment">// [3]</span></span><br></pre></td></tr></table></figure></p>
<p>实现了绑定指定的 this 并返回新函数，也看到传入别的参数会丢失。接着实现第二点：可以设置预设参数，并且将预设参数以及之后调用的参数按顺序传入原函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>); <span class="comment">// arguments是类数组，把类数组对象转化成数组，因为apply里传的参数是数组。因为第一个arguments第一个参数是context，所以需要截取后面的参数。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> innerArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">var</span> finalArgs = args.concat(innerArgs); <span class="comment">// 将 bind 传入的参数和调用返回函数传入的参数一起传入原函数中</span></span><br><span class="line">        <span class="keyword">return</span> self.apply(context, finalArgs)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// args是[1,2] innerArgs是[]</span></span><br><span class="line">fn.bind(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>)(); <span class="comment">// [1,2] </span></span><br><span class="line"><span class="comment">// args是[1,2] innerArgs是[3]</span></span><br><span class="line">fn.bind(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>); <span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure></p>
<p>第三点：bind 绑定的函数可以当做构造函数来使用。<br>那现在如果用 new 创建的话会是什么情况呢？<br>举例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> emptyObj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> YAxisPoint = Point.bind(emptyObj, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> axisPoint = <span class="keyword">new</span> YAxisPoint(<span class="number">5</span>);</span><br><span class="line">axisPoint.x <span class="comment">// undefined</span></span><br><span class="line">axisPoint.y <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">emptyObj.x <span class="comment">// 0</span></span><br><span class="line">emptyObj.x <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">axisPoint <span class="keyword">instanceof</span> Point; <span class="comment">// false</span></span><br><span class="line">axisPoint <span class="keyword">instanceof</span> YAxisPoint; <span class="comment">// true axisPoint是YAxisPoint的实例，但不是Point的实例</span></span><br></pre></td></tr></table></figure>
<p>可以看到，用 new 创建对象实例时，并没有将构造函数的 this 指向实例化对象，bind 绑定的还是 emptyObj，目前和普通函数调用没有区别。<br>那 <code>new YAxisPoint()</code>时又做了什么呢？var a = new A()，new 一个对象主要做了这些操作：</p>
<ol>
<li>创建一个对象。</li>
<li>将对象的 [[prototype]] 属性指向构造函数的原型对象上（一定是构造函数的原型对象）。</li>
<li>把新对象绑定到构造函数的 this。</li>
<li>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。</li>
</ol>
<p>所以，如果用 new 调用的时候，执行第二步会将新对象的 [[prototype]] 属性指向构造函数（YAxisPoint）的原型对象，所以<code>axisPoint instanceof YAxisPoint</code>是 true，而构造函数 YAxisPoint() 是<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> innerArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">var</span> finalArgs = args.concat(innerArgs); </span><br><span class="line">    <span class="keyword">return</span> self.apply(context, finalArgs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>context 是调用 bind 时传进去的 empty，调用 Point 函数的还是 empty，也就是说上下文指向的是传入的empty，并没有把新对象 axisPoint 绑定上，所以会发现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">emptyObj.x // 0</span><br><span class="line">emptyObj.x // 5</span><br><span class="line">axisPoint.x // undefined</span><br><span class="line">axisPoint.y // undefined</span><br></pre></td></tr></table></figure></p>
<p>所以我们现在要做的是，如果是 new 创建的对象，需要把调用函数的 this 指向新对象（也就是构造函数 this，看下面分析），那怎么判断是 new 调用的构造函数呢？我们来打印一下调用时 this 的指向。加上 new 调用的判断：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> resultFunc =  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);  <span class="comment">// 打印this</span></span><br><span class="line">        <span class="keyword">var</span> innerArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">var</span> finalArgs = args.concat(innerArgs);</span><br><span class="line">        <span class="keyword">return</span> self.apply(context, finalArgs)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultFunc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>发现如果是普通函数调用，this 指向的是全局的 Window 对象 <code>Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …}</code>，如果是 new 调用，this 指向的是 resultFunc 这个函数<code>resultFunc {}</code>。<br> 再反过来看 new 一个对象的过程第三步：<strong>把新对象绑定到构造函数的 this</strong>，也正好说明了这点：new调用时，this指向的是构造函数的this。<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> resultFunc =  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> innerArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">var</span> finalArgs = args.concat(innerArgs);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> resultFunc) &#123;</span><br><span class="line">            <span class="keyword">return</span> self.apply(<span class="keyword">this</span>, finalArgs)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> self.apply(context, finalArgs)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="keyword">return</span> resultFunc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 看到axisPoint可以正常赋值，但是<code>axisPoint instanceof Point</code>为 false<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axisPoint.x <span class="comment">// 0</span></span><br><span class="line">axisPoint.y <span class="comment">// 5</span></span><br><span class="line">axisPoint <span class="keyword">instanceof</span> Point <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>还需要将构造函数的原型指向原本调用函数 self 的原型，所以需要加上<code>resultFunc.prototype = self.prototype</code>。而一般实现这种继承都需要加入一个中间函数，否则改变 resultFunc.prototype 会改变 self.prototype 的值。所以最终代码为：<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> resultFunc =  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> innerArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">var</span> finalArgs = args.concat(innerArgs);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> resultFunc) &#123;</span><br><span class="line">            <span class="keyword">return</span> self.apply(<span class="keyword">this</span>, finalArgs)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> self.apply(context, finalArgs)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    F.prototype = self.prototype;</span><br><span class="line">    resultFunc.prototype = <span class="keyword">new</span> F();</span><br><span class="line">    <span class="keyword">return</span> resultFunc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/07/flex-grow-child-not-filling-height-of-parent/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ruirui">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ruirui's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/07/flex-grow-child-not-filling-height-of-parent/" itemprop="url">flex-grow 子元素高度百分比无效</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-07T15:42:26+08:00">2018-12-07</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p> chrome 浏览器，flex 布局，设置 flex-grow 部分的子元素无法用百分比适应父元素尺寸，而 flex:1 可以。<a href="https://jsfiddle.net/ruirui/ahcy8p0w/" target="_blank" rel="noopener">例子</a>如下：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  #wrapper &#123;</span><br><span class="line">    height: 800px;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-direction: column;</span><br><span class="line">  &#125;</span><br><span class="line">  header, footer &#123;</span><br><span class="line">    height: 30px;</span><br><span class="line">  &#125;</span><br><span class="line">  main &#123;</span><br><span class="line">    /* flex: 1; */</span><br><span class="line">    flex-grow: 1;</span><br><span class="line">    background-color: red;</span><br><span class="line">  &#125;</span><br><span class="line">  #test &#123;</span><br><span class="line">    height: 100%;</span><br><span class="line">    background-color: yellow;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;wrapper&quot;&gt;</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">    header</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;div id=&quot;test&quot;&gt;</span><br><span class="line">      我是id为test的div，我设置了height: 100%</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">  &lt;footer&gt;</span><br><span class="line">    footer</span><br><span class="line">  &lt;/footer&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p> 当 main 设置为 flex-grow 时，子元素设置 100% 无效。不能撑大到父元素的高度。</p>
<p> 为什么呢：<br> 看W3C上关于高度的定义：</p>
<blockquote>
<p><a href="https://www.w3.org/TR/CSS22/visudet.html#the-height-property" target="_blank" rel="noopener">10.5 Content height: the ‘height’ property</a><br> percentage<br> Specifies a percentage height. The percentage is calculated with respect to the height of the generated box’s containing block. If the height of the containing block is not specified explicitly and this element is not absolutely positioned, the value computes to auto.<br> auto<br> The height depends on the values of other properties.</p>
</blockquote>
<p> 即：如果高度设置百分比，那百分比是计算的相对于包含块的高度。如果包含块高度未指定(取决于内容高度)，而且此元素不是绝对定位，那该百分比值就等同于auto。</p>
<p> 此外，chrome 也接受：当父元素用了 flex-grow ，同时也有 flex-basis 属性（固定的任何值，包括flex-basis:0）时，子元素可以引用父元素的高度。 </p>
<p>  即此<a href="https://jsfiddle.net/ruirui/c32mwL5o/" target="_blank" rel="noopener">例子</a>是可以的。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">#outer &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-direction: column;</span><br><span class="line">  height: 300px;</span><br><span class="line">  background-color: white;</span><br><span class="line">  border: 1px solid red;</span><br><span class="line">&#125;</span><br><span class="line">#middle &#123;</span><br><span class="line">  flex-grow: 1;</span><br><span class="line">  flex-basis: 1px;</span><br><span class="line">  background-color: yellow;</span><br><span class="line">&#125;</span><br><span class="line">#inner &#123;</span><br><span class="line">  height: 100%;</span><br><span class="line">  background-color: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;outer&quot;&gt;</span><br><span class="line">    &lt;div id=&quot;middle&quot;&gt;</span><br><span class="line">      &lt;div id=&quot;inner&quot;&gt;</span><br><span class="line">        INNER</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p> 那为什么 flex:1 可以呢？<br> flex 是 flex-grow，flex-shrink，flex-basis 的缩写。<br>  <strong>flex(default)</strong>：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flex-grow: 0</span><br><span class="line">flex-shrink: 1</span><br><span class="line">flex-basis: auto</span><br></pre></td></tr></table></figure></p>
<p> <strong>flex:1</strong>：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flex-grow: 1</span><br><span class="line">flex-shrink: 1</span><br><span class="line">flex-basis: 0</span><br></pre></td></tr></table></figure></p>
<p> <strong>flex-grow:1</strong>：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flex-grow: 1;</span><br><span class="line">flex-shrink: 1; </span><br><span class="line">flex-basis: auto;</span><br></pre></td></tr></table></figure></p>
<p> 所以二者主要区别在于flex-basis。</p>
<p>  <code>flex-basis: auto</code>：main 元素的高度由内容高度来决定，flex-grow 分配剩余空间（800px-60px），但是是一个伪分配，flex-grow 更像是一个min-height。<br>  <code>flex-basis: 0</code>：等同于 main 元素的高度是0，flex-grow 将剩余空间实实在在的分配给 main 元素，给 main 元素增加高度。</p>
<p>解决办法是：</p>
<ol>
<li>给父元素指定一个固定高度， min-height 或 max-height 不行。</li>
<li>将父元素 main 设置为 relative，子元素设置 absolute 使其脱离文档流定位。</li>
<li>嵌套 flex 布局（推荐用法）。设置 main 为<code>display:flex</code>作为 flex 容器，align-items 默认值为 stretch ，这样子元素会自动拉伸以适应父容器的高度。但要注意：移除内部元素的高度属性（height：100%），否则会忽略父元素的<code>align-items:stretch</code> 。为了使 stretch 属性起作用，内部高度必须设置为 auto 。</li>
</ol>
<p>参考链接<br><a href="http://zhoon.github.io/css3/2014/08/23/flex.html" target="_blank" rel="noopener">http://zhoon.github.io/css3/2014/08/23/flex.html</a><br><a href="https://stackoverflow.com/questions/33636796/chrome-safari-not-filling-100-height-of-flex-parent" target="_blank" rel="noopener">https://stackoverflow.com/questions/33636796/chrome-safari-not-filling-100-height-of-flex-parent</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/07/a-bug-from-transform/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ruirui">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ruirui's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/07/a-bug-from-transform/" itemprop="url">由 transform 引发的 bug</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-07T09:53:17+08:00">2018-12-07</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在 vue 项目的某页面用 better-scroll 滚动条组件的过程中发现：刷新当前页面滚动条显示正常，从其他页面切换过来显示异常（有滚动条但显示异常）。</p>
<p>第一反应是被别的页面样式影响到了，排查没问题。</p>
<p>接着分析 better-scroll 可能出现滚动条异常的原因：1.层级关系出错，2.计算高度出错。</p>
<ol>
<li>层级关系</li>
</ol>
<p>外层 wrapper 层，固定高度，且设置<code>overflow:hidden</code>。内层第一个子元素content层，高度大于 wrapper 显示滚动条。页面出现滚动条，不是此问题。</p>
<ol start="2">
<li>计算高度出错</li>
</ol>
<p>打印BS对象，查看<code>hasVerticalScroll</code>、<code>scrollerHeight</code>和<code>wrapperHeight</code>值。如果是因为未出现滚动条，则一般<code>scrollerHeight</code>小于<code>wrapperHeight</code>。可能是因为在数据未渲染成功时加载滚动条导致。</p>
<p>查看内置属性，发现外层高度<code>wrapperHeight</code>在切换页面时会出现塌陷。获取数据后用 setTimeout 延迟几秒就正常，以为是常见的数据未渲染成功时就加载导致的，分析这个过程又持续了好久无果。又发现设置 setTimeout 延迟 3 秒就正常，延迟时间小于 1 秒就失败，限制网速也可以正常显示。这就很诡异了，又不是数据渲染的问题，但延迟时间又有效果。折腾好久还是没找到问题。<br>（其实当时重点关注不应该是这里，应该主要分析切换页面高度异常这个问题）</p>
<p>又一层层分析打印各个元素及其高度，发现有元素打印出来指向不到页面选中的状态，也就是说，虽然控制台打印出来了，但是元素不在这个页面，这个问题很重要了，为什么会出现这种情况呢，难道有动画？往上层找发现页面的外层框架（d2-admin）在某个页面（路由）切换的时候会有一个0.5秒的动画，同时也发现此页面最外层 div 高度是 0 (<a href="/2018/12/07/flex-grow-child-not-filling-height-of-parent/">flex-grow 子元素设置百分比无效</a>)。外层框架是 flex布局。而且只有在有 transform 属性的时候才会出现这个问题。</p>
<p> 用一个简单的<a href="https://jsfiddle.net/ruirui/9yqeo05x/" target="_blank" rel="noopener">例子</a>还原一下。<br> <img src="demo.gif" alt="demo"></p>
<p> 延长动画的时间，并将 page 设置成固定高度，比较明显的看到在动画结束前内层元素 page-inner 都没有撑开到正常的高度。当去掉动画或者将外层 page 设置为<code>position:absolute</code>，都可以解决问题。</p>
<p> 那么问题来了，transform 动画为什么会导致内层元素高度失效？设置为绝对定位为什么就不受动画的影响？</p>
<p> <strong> <code>transform</code>会提升元素的垂直地位，使元素表现出<code>position:relative</code>的特性，导致堆叠上下文(<code>Stacking Context</code>)和包含块(<code>Containing Block</code>)的创建，其后代元素（含有fixed属性或absolute属性）会以该父元素作为包含块。</strong>而当父元素page元素为<code>position:relative</code>的时候，子元素 page-inner 会根据父元素来定位，所以导致高度为 0 ，去掉动画后，也就没有了<code>transform</code>属性。就根据再上一级来定位。</p>
<p> 至此，解决了花费时久的坑。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/25/js-event-loop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ruirui">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ruirui's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/25/js-event-loop/" itemprop="url">JS 事件运行机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-25T13:49:46+08:00">2018-09-25</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>网上看了好多关于 JS 事件循环的文章，从各个文章中吸收了点自己需要的，整理总结如下。</p>
<h3 id="JS-运行机制"><a href="#JS-运行机制" class="headerlink" title="JS 运行机制"></a>JS 运行机制</h3><p>JS是单线程的，某一时刻只能执行特定的一个任务，并且会阻塞其他任务执行，浏览器使用事件循环（Event Loop）机制来处理事件。</p>
<p>事件循环的任务队列有两种：macro task 和 micro task。<br>常见的 macro task 有：script（整体代码）、setTimeout、setInterval、I/O、UI交互事件。<br>常见的 micro task 有：promise.then、process.nextTick、MutationObserver。</p>
<p>一次完整的 Event loop 过程如下：</p>
<ul>
<li>初始状态：<strong>调用栈</strong>为空，micro task 为空，macro task 有script（整体代码）。</li>
<li>接着：执行macro task 中的 script 代码，碰到同步任务，推入调用栈执行，碰到异步任务，将其分发到对应的任务队列中。此时，macro task 中的第一个任务（script）执行完了，script 被移出 macro 队列，</li>
<li>然后：开始清空 micro task 队列。也就是，执行一个 macro 队列，清空所有的 micro 队列。</li>
<li>执行渲染操作，更新界面。</li>
<li>检查看是否有 web worker 任务，有的话则处理。</li>
</ul>
<p>每一次循环都是这样一个过程：<br><img src="event-loop.png" alt="event-loop"><br>以一个简单例子描述：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise'</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br></pre></td></tr></table></figure></p>
<p>分析一下执行过程：</p>
<ul>
<li>初始状态：macro 中是整体的 script 代码。</li>
<li>开始执行 script，第一个console.log(‘script start’)，直接输出。</li>
<li>接着碰到 setTimeout，将其放入 macro 中。</li>
<li>接着 new promise 直接打印出 Promise，因为 Promise 实例一旦创建，执行器立刻执行，后续的.then放入 micro 中。</li>
<li>直接打印 script end。</li>
<li>此时，macro 中的第一个任务结束，要开始清空 micro 了，于是输出、promise1、promise2。</li>
<li>接着执行下一轮事件循环，执行下一个 macro task，输出 setTimeout。</li>
</ul>
<p>于是，最终输出顺序是：script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTimeout。</p>
<p>如果加上 async/await 呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async2 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line">async1()</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise'</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br></pre></td></tr></table></figure>
<p>加上 async/await 发现「async1 end」的输出顺序有了差异。<br>chrome 70 版本是：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">script start =&gt; async2 end =&gt; <span class="function"><span class="params">Promise</span> =&gt;</span> script end =&gt; <span class="function"><span class="params">promise1</span> =&gt;</span> promise2 =&gt; async1 end =&gt; setTimeout。</span><br></pre></td></tr></table></figure></p>
<p>chrome 73 版本是：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">script start =&gt; async2 end =&gt; <span class="function"><span class="params">Promise</span> =&gt;</span> script end =&gt; async1 end =&gt; <span class="function"><span class="params">promise1</span> =&gt;</span> promise2 =&gt; setTimeout。</span><br></pre></td></tr></table></figure></p>
<p>所以问题是<strong>await 做了什么？</strong>async/await 其实是 promise 的语法糖，promise 的事件循环机制理解了，那将 await 转化为 promise 就好理解了。</p>
<p>我们知道 async 函数总会返回一个 promise，看<a href="https://tc39.github.io/ecma262/#await" target="_blank" rel="noopener">官方规范</a>：<br>也就是说：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等价于：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> RESOLVE(async2).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而 RESOLVE() 几乎等于 Promise.resolve()。几乎等于的意思就是还是有区别，下面看具体区别。</p>
<h3 id="RESOLVE-vs-Promise-resolve"><a href="#RESOLVE-vs-Promise-resolve" class="headerlink" title="RESOLVE() vs Promise.resolve()"></a>RESOLVE() vs Promise.resolve()</h3><p>如果参数是个非 thenable 值，那么 Promise.resolve(non-thenable) 等价于 RESOLVE(non-thenable)。<br>但如果是个 thenable 对象，就不相等了，因为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RESOLVE()</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(thenable)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>等价于<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    thenable.then(resolve)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>也就是说：RESOLVE() 会产生一个新的 promise，尽管该 promise 会 resolve，但这个过程是异步的，所以进入队列的是 Promise.resolve 的 then 过程，thenable 的 then 要等到执行到该 promise 的 then 之后才能执行，所以时序会靠后，举个明显的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RESOLVE(thenable)</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(p1)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>但<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Promise.resolve(thenable)</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">Promise</span>.resolve(p1).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br></pre></td></tr></table></figure></p>
<p>回到上面await：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等价于：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> RESOLVE(async2).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再等价于：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      async2().then(resolve)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以，「async1 end」的输出会靠后。</p>
<h3 id="Await-规范的更新"><a href="#Await-规范的更新" class="headerlink" title="Await 规范的更新"></a>Await 规范的更新</h3><blockquote>
<p>根据最新的TC39决议，await 将直接使用 Promise.resolve() 相同语义。</p>
</blockquote>
<p>也就是说：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等价于：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(async2).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Promise.resolve(p): 如果传入的 p 是一个 promise 实例，则会直接返回 p，不做任何修改，所以再次等价于：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  async2().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>chrome canary 73 采用了这种实现，所以输出会靠前。</p>
<p>参考文章：<br><a href="https://github.com/xianshenglu/blog/issues/60" target="_blank" rel="noopener">https://github.com/xianshenglu/blog/issues/60</a><br><a href="https://segmentfault.com/q/1010000016147496" target="_blank" rel="noopener">https://segmentfault.com/q/1010000016147496</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/28/observer-pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ruirui">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ruirui's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/28/observer-pattern/" itemprop="url">从一道题理解观察者模式（自定义事件）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-28T10:16:21+08:00">2018-08-28</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>看到过许多关于观察者模式的介绍，大都是大篇理论性的概念开始，看的云里雾里的，直到看到这道题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">请实现下面的自定义事件 Event 对象的接口，功能见注释(测试1)</span><br><span class="line">该 Event 对象的接口需要能被其他对象拓展复用(测试2)</span><br><span class="line"></span><br><span class="line">// 测试1</span><br><span class="line">Event.on(&apos;test&apos;, function (result) &#123;</span><br><span class="line">    console.log(result);</span><br><span class="line">&#125;);</span><br><span class="line">Event.on(&apos;test&apos;, function () &#123;</span><br><span class="line">    console.log(&apos;test&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">Event.emit(&apos;test&apos;, &apos;hello world&apos;); // 输出 &apos;hello world&apos; 和 &apos;test&apos;</span><br><span class="line"></span><br><span class="line">// 测试2</span><br><span class="line">var person1 = &#123;&#125;;</span><br><span class="line">var person2 = &#123;&#125;;</span><br><span class="line">Object.assign(person1, Event);</span><br><span class="line">Object.assign(person2, Event);</span><br><span class="line">person1.on(&apos;call1&apos;, function () &#123;</span><br><span class="line">    console.log(&apos;person1&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">person2.on(&apos;call2&apos;, function () &#123;</span><br><span class="line">    console.log(&apos;person2&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">person1.emit(&apos;call1&apos;); // 输出 &apos;person1&apos;</span><br><span class="line">person1.emit(&apos;call2&apos;); // 没有输出</span><br><span class="line">person2.emit(&apos;call1&apos;); // 没有输出</span><br><span class="line">person2.emit(&apos;call2&apos;); // 输出 &apos;person2&apos;</span><br><span class="line">var Event = &#123;</span><br><span class="line">    // 通过on接口监听事件eventName</span><br><span class="line">    // 如果事件eventName被触发，则执行callback回调函数</span><br><span class="line">    on: function (eventName, callback) &#123;</span><br><span class="line">        //你的代码</span><br><span class="line">    &#125;,</span><br><span class="line">    // 触发事件 eventName</span><br><span class="line">    emit: function (eventName) &#123;</span><br><span class="line">        //你的代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>首先看测试1，需要实现一个 Event 对象，用 on 方法注册了两个 test 属性的事件，当 emit 触发事件时，触发 test 属性对应的回调。on 方法也就是注册事件，需要传两个参数，第一个是事件类型，第二个是该事件的回调，当调用 emit 方法的时候，触发对应属性的回调。总结来说，主要就是实现两点：注册事件和触发事件。这就是典型的观察者模式啊！<br>通过上面分析，要写的代码就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var Event = &#123;</span><br><span class="line">  subs: &#123;&#125;,</span><br><span class="line">  on: function(eventName, callback) &#123;</span><br><span class="line">    if(!this.subs) &#123;</span><br><span class="line">      this.subs = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!this.subs[eventName]) &#123;</span><br><span class="line">      this.subs[eventName] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    this.subs[eventName].push(callback);</span><br><span class="line">  &#125;,</span><br><span class="line">  emit: function(eventName) &#123;</span><br><span class="line">    var arg = arguments[1];</span><br><span class="line">    if(!eventName) &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    this.subs[eventName] &amp;&amp; this.subs[eventName].forEach(function(item)&#123;</span><br><span class="line">      item(arg);</span><br><span class="line">    &#125;)</span><br><span class="line">   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上面的例子简单理解一下观察者模式：</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式也叫发布-订阅模式（当然这两个有区别，后续说区别），定义了对象的一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都得到通知。由 Subject（主体）和 Observe（观察者）组成，Subject 负责发布事件，Observe 通过订阅事件来观察 Subject，一旦 Subject 发布更新，Observe 会得到通知。DOM 事件就是典型的观察者模式，元素注册事件，当触发事件时调用注册的回调。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">el.addEventListener(&apos;click&apos;,function(e)&#123;</span><br><span class="line">  console.log(e);</span><br><span class="line">&#125;, false)</span><br></pre></td></tr></table></figure></p>
<h2 id="观察者模式-VS-发布-订阅者模式"><a href="#观察者模式-VS-发布-订阅者模式" class="headerlink" title="观察者模式 VS 发布-订阅者模式"></a>观察者模式 VS 发布-订阅者模式</h2><h3 id="观察者模式-1"><a href="#观察者模式-1" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式中，观察者直接订阅目标事件，目标改变时，调用观察者的通知方法，是一种紧耦合的状态。</p>
<p><img src="observe.jpg" alt="observe.jpg"></p>
<p>实现方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Subject &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.subs = [];</span><br><span class="line">  &#125;</span><br><span class="line">  subscribe(sub) &#123;</span><br><span class="line">    this.subs.push(sub);</span><br><span class="line">  &#125;</span><br><span class="line">  update() &#123;</span><br><span class="line">    this.subs.forEach(sub=&gt;&#123;</span><br><span class="line">      sub.notify();</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Observer &#123;</span><br><span class="line">  constructor(data) &#123;</span><br><span class="line">    this.data = data;</span><br><span class="line">  &#125;</span><br><span class="line">  notify() &#123;</span><br><span class="line">    console.log(this.data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let subject = new Subject();</span><br><span class="line">let obj1 = new Observer(&apos;hello&apos;);</span><br><span class="line">let obj2 = new Observer(&apos;world&apos;);</span><br><span class="line">subject.subscribe(obj1);</span><br><span class="line">subject.subscribe(obj2); // obj1 和 obj2 订阅了 subject</span><br><span class="line">subject.update(); // subject 更新通知所有的 观察者 obj1 和 ob2，调用 notify 方法</span><br></pre></td></tr></table></figure></p>
<h3 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h3><p>发布-订阅模式是广义的观察者模式，发布-订阅模式会抽离出一个<strong>调度中心</strong>(Event Bus)，负责对订阅者的管理，使得发布者和订阅者解耦，便于扩展。</p>
<p><img src="pub-sub.jpg" alt="pub-sub.jpg"></p>
<p>Vue 非父子组件通信方式 Event Bus 就是这种模式。通过 Event Bus 管理事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 全局注册事件中心</span><br><span class="line">var bus = new Vue();</span><br><span class="line"></span><br><span class="line">// 在组件 A 中注册监听事件</span><br><span class="line">bus.$on(&apos;id-selected&apos;, function()&#123;&#125;);</span><br><span class="line"></span><br><span class="line">// 在组件 B 触发事件</span><br><span class="line">bus.$emit(&apos;id-selected&apos;,&apos;&apos;);</span><br></pre></td></tr></table></figure></p>
<p>实现方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class EventBus &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.subs = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  on(subject, callback) &#123;</span><br><span class="line">    if(!this.subs[subject]) &#123;</span><br><span class="line">      this.subs[subject] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    this.subs[subject].push(callback);</span><br><span class="line">  &#125;</span><br><span class="line">  emit(subject, params) &#123;</span><br><span class="line">   if(!this.subs[subject]) &#123;</span><br><span class="line">     return</span><br><span class="line">   &#125;</span><br><span class="line">   this.subs[subject].forEach(callback=&gt;&#123;</span><br><span class="line">     callback(...params);</span><br><span class="line">   &#125;)    </span><br><span class="line">   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const event = new EventBus();</span><br><span class="line">event.on(&apos;update&apos;, function(data)&#123;</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;)</span><br><span class="line">event.emit(&apos;update&apos;, 123);</span><br></pre></td></tr></table></figure>
<p>接着回到题目看测试2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 测试2</span><br><span class="line">var person1 = &#123;&#125;;</span><br><span class="line">var person2 = &#123;&#125;;</span><br><span class="line">Object.assign(person1, Event);</span><br><span class="line">Object.assign(person2, Event);</span><br><span class="line">person1.on(&apos;call1&apos;, function () &#123;</span><br><span class="line">    console.log(&apos;person1&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">person2.on(&apos;call2&apos;, function () &#123;</span><br><span class="line">    console.log(&apos;person2&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">person1.emit(&apos;call1&apos;); // 输出 &apos;person1&apos;</span><br><span class="line">person1.emit(&apos;call2&apos;); // 没有输出</span><br><span class="line">person2.emit(&apos;call1&apos;); // 没有输出</span><br><span class="line">person2.emit(&apos;call2&apos;); // 输出 &apos;person2&apos;</span><br></pre></td></tr></table></figure></p>
<p>为两个 person 注册独立的事件，如果按之前的代码，测试输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person1</span><br><span class="line">person2</span><br><span class="line">person1</span><br><span class="line">person2</span><br></pre></td></tr></table></figure></p>
<p>也就是，两个 person 并没有互相独立，person1 注册的方法 person2 也会有。因为有个 Object.assign() 方法，Object.assign(target, source)用于将源对象（source）的<strong>所有可枚举</strong>的属性，复制到目标对象（target）中，这个方法只是第一层属性的拷贝，如果属性的值是个对象，那值就是对象的引用，所以两个 person 里的 subs 是同一个引用。<br>解决方法最简单的是实现深度克隆，但题目已经固定了方式，所以必须将 subs 设置为不可枚举的属性。这样在每个 person 调用的时候都产生新的 subs。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var Event = &#123;</span><br><span class="line">  on: function (eventName, callback) &#123;</span><br><span class="line">    if(!this.subs) &#123;</span><br><span class="line">      Object.defineProperty(this, &quot;subs&quot;, &#123;</span><br><span class="line">        value: &#123;&#125;,</span><br><span class="line">        enumerable: false,</span><br><span class="line">        configurable: true,</span><br><span class="line">        writable: true</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if(!this.subs[eventName])&#123;</span><br><span class="line">      this.subs[eventName]=[];</span><br><span class="line">    &#125;</span><br><span class="line">    this.subs[eventName].push(callback);</span><br><span class="line">  &#125;,</span><br><span class="line">  emit: function(eventName) &#123;</span><br><span class="line">    var arg = arguments[1];</span><br><span class="line">    if(!eventName) &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    this.subs[eventName] &amp;&amp; this.subs[eventName].forEach(function(item)&#123;</span><br><span class="line">      item(arg);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/08/webpack-and-dynamic-Imports/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ruirui">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ruirui's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/08/webpack-and-dynamic-Imports/" itemprop="url">『译』Webpack Import 异步加载</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-08T11:03:13+08:00">2018-05-08</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文链接：<a href="https://medium.com/front-end-hacking/webpack-and-dynamic-imports-doing-it-right-72549ff49234" target="_blank" rel="noopener">Webpack and Dynamic Imports: Doing it Right</a></p>
<h2 id="webpack和异步加载"><a href="#webpack和异步加载" class="headerlink" title="webpack和异步加载"></a>webpack和异步加载</h2><p>在webpackv1中，我们推荐使用AMD的require或者webpack的require.ensure来实现动态加载模块。但在这篇文章，我们将介绍webpackV2支持的<a href="https://doc.webpack-china.org/api/module-methods/#import-" target="_blank" rel="noopener">ES2015 dynamic import方式</a>来加载模块，需要用到babel插件和webpack一些特性。</p>
<h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><p>语法比较简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import(&quot;module/foo&quot;).then(foo =&gt; console.log(foo.default))</span><br></pre></td></tr></table></figure>
<p>上面的代码将在运行时加载foo模块，打印出模块的默认输出。import接收一个字符串参数。</p>
<h2 id="动态加载模块的语法"><a href="#动态加载模块的语法" class="headerlink" title="动态加载模块的语法"></a>动态加载模块的语法</h2><p>假设你的应用在移动端和PC端有不用的展现方式，只有一种响应式的设计不能满足要求的，那么就需要在不同的设备上加载不同的页面去渲染。作为一个聪明的开发者，如果用户使用的是移动端那么你是不希望去加载PC端的代码，反之亦然。那么将会用以下方式处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default function pageLoader(platform) &#123;</span><br><span class="line">  switch (platform=&quot;desktop&quot;) &#123;</span><br><span class="line">    case &quot;mobile&quot;:</span><br><span class="line">      return import(&quot;components/MyMobileComponent&quot;);</span><br><span class="line"></span><br><span class="line">    case &quot;desktop&quot;:</span><br><span class="line">      return import(&quot;components/MyDesktopComponent&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“但是，这只是一个简单的例子，真正项目里不会只有一个页面要处理”</p>
<p>所以，尽管我们使用了组件的动态加载方式，但还是不够灵活，让我们重构一下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export default function pageLoader(platform, componentName) &#123;</span><br><span class="line">  switch (platform=&quot;desktop&quot;) &#123;</span><br><span class="line">    case &quot;mobile&quot;:</span><br><span class="line">      return import(`components/mobile/$&#123;componentName&#125;`);</span><br><span class="line">    case &quot;desktop&quot;:</span><br><span class="line">      return import(`components/desktop/$&#123;componentName&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“还是不太好，应用不只是支持这两个设备，以后可能会支持更多的设备”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const load = (platform=&quot;desktop&quot;) =&gt; componentName =&gt; import(`components/$&#123;platform&#125;/$&#123;componentName&#125;`);</span><br><span class="line">export const loadDesktopComponent = load(&quot;desktop&quot;);</span><br><span class="line">export const loadMobileComponent = load(&quot;mobile&quot;);</span><br><span class="line"></span><br><span class="line">export default load;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们采用了更优雅的方法。可以适用任何我们想用的平台。</p>
<h2 id="加载文件存在的问题"><a href="#加载文件存在的问题" class="headerlink" title="加载文件存在的问题"></a>加载文件存在的问题</h2><p>在webpack中通常我们处理图片的方式是使用file-loader，file-loader会将文件路径映射到模块内。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import(`assets/images/$&#123;imageName&#125;.jpg`).then( src =&gt; ... )</span><br></pre></td></tr></table></figure>
<p>现在存在的问题是：如果你想要动态加载一个文件，像这个例子中的图片，webpack会生成一个额外的chunk：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">webpackJsonp([4],&#123;</span><br><span class="line"></span><br><span class="line">/***/ 850:</span><br><span class="line">/***/ (function(module, exports, __webpack_require__) &#123;</span><br><span class="line"></span><br><span class="line">module.exports = __webpack_require__.p + &quot;6089b36e59a28c41600c17626366cde0.jpg&quot;;</span><br><span class="line"></span><br><span class="line">/***/ &#125;)</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">//# sourceMappingURL=4.chunk.a6e0a95123529f9afcc5.js.map</span><br></pre></td></tr></table></figure>
<p>所以最大的问题是： 当你请求一个异步加载的图片时，会先发一个网络请求去请求该模块的chunk，再去请求图片。每个图片都需要请求两次才能加载成功，如果使用https的话那么就更糟糕了。</p>
<p>那么如何解决这个问题呢：</p>
<h2 id="webpack“神奇的注释”"><a href="#webpack“神奇的注释”" class="headerlink" title="webpack“神奇的注释”"></a>webpack“神奇的注释”</h2><p>webpack为动态引入增加了一个非常好的特性：神奇的注释。在配置中添加一些注释，以告诉webpack如何创建并加载该chunk。</p>
<h3 id="Webpack-Mode"><a href="#Webpack-Mode" class="headerlink" title="Webpack Mode"></a>Webpack Mode</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import(/* webpackMode: &quot;eager&quot; */ `assets/images/$&#123;imageName&#125;.jpg`)</span><br></pre></td></tr></table></figure>
<p>这将使webpack把该异步加载的chunk加入到其父chunk中，不再去单独创建一个chunk。这种方式下，所有的文件路径在父chunk加载的时候就加载进来了。<br>webpack有四种模式（lazy，lazy-once，eager，weak）来处理异步加载。具体看<a href="https://doc.webpack-china.org/api/module-methods/" target="_blank" rel="noopener">这里</a>。</p>
<h3 id="Webpack-Chunk名称"><a href="#Webpack-Chunk名称" class="headerlink" title="Webpack Chunk名称"></a>Webpack Chunk名称</h3><p>“hey，我注意到webpack将异步加载的模块命名为数字，这样调试起来有点麻烦，因为我不知道某个特定的chunk是否加载！”</p>
<p>我们既然可以控制加载方式，那么也可以通过注释去改变chunk的名称，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import(/* webpackChunkName: &quot;foo-image&quot; */ &quot;assets/images/foo.jpg&quot;);</span><br><span class="line">import(/* webpackChunkName: &quot;bar-module&quot; */ &quot;modules/bar&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="Prefetch-Preload"><a href="#Prefetch-Preload" class="headerlink" title="Prefetch/Preload"></a>Prefetch/Preload</h3><p>注：这个特性在webpackV4.6之后才有</p>
<p>如果你使用的是http2，那么<a href="https://http2.github.io/faq/#why-is-http2-multiplexed" target="_blank" rel="noopener">最好将大chunk分割成小的chunk</a>。所以，最好的方式是将异步加载的chunk和父chunk分开并且在请求图片前加载好图片的chunk。<br>那就需要用webpackPrefetch: true来替代webpackMode: eager。</p>
<p>“那么Prefetch和Preload有什么区别吗？”</p>
<p>webpack的文档解释的更详细：</p>
<blockquote>
<ul>
<li>A preloaded chunk starts loading in parallel to the parent chunk. A prefetched chunk starts after the parent chunk finish.<br>preload：异步chunk和其父chunk是并行加载的。prefetch：异步chunk是在父chunk加载完之后再加载的。</li>
<li>A preloaded chunk has medium priority and instantly downloaded. A prefetched chunk is downloaded in browser idle time.<br>preload：异步chunk在浏览器中有中等优先级，会立即下载。prefetch：异步chunk会在浏览器空闲的时候下载。</li>
<li>A preloaded chunk should be instantly requested by the parent chunk. A prefetched chunk can be used anytime in the future.<br>preload：异步chunk在父chunk加载完之后会立刻发起请求。prefetch：异步chunk会在父chunk加载完之后的任意时间发起。</li>
<li>Browser support is different.</li>
</ul>
</blockquote>
<p>浏览器支持是有差异的</p>
<p>因为prefetch chunk会在浏览器空闲的时候加载，所以可以加数字注释说明chunk加载的顺序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 0 is same as true</span><br><span class="line">import(/* webpackPrefetch: 0 */ &quot;assets/images/foo.jpg&quot;);</span><br><span class="line">// this loads first as 1 &gt; 0 (or true)</span><br><span class="line">import(/* webpackPrefetch: 1 */ &quot;modules/bar&quot;);</span><br><span class="line">// this one will be the last!</span><br><span class="line">import(/* webpackPrefetch: -100 */ &quot;modules/slowpoke&quot;);</span><br></pre></td></tr></table></figure>
<p>顺序将是：bar&gt;foo&gt;slowpoke。</p>
<h2 id="深入研究代码分割"><a href="#深入研究代码分割" class="headerlink" title="深入研究代码分割"></a>深入研究代码分割</h2><p>如果你想要深入研究在单页应用中是如何进行懒加载的，可以看我之前的两篇文章，虽然是用react作为例子的，你可以在任何基于SPA的框架/库中运用相同的思想：</p>
<p><a href="https://medium.com/front-end-hacking/lazy-loading-with-react-and-webpack-2-8e9e586cf442" target="_blank" rel="noopener">Lazy Loading with React and Webpack 2</a></p>
<p><a href="https://medium.com/front-end-hacking/lazy-loading-with-react-redux-and-webpack-2-35ad6fc1b640" target="_blank" rel="noopener">Lazy Loading with React + Redux and Webpack 2</a></p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>代码分割是一个强大的功能，可以使应用变得更快，更智能的去加载依赖关系。但是正如uncle Ben曾经说的：”with great power comes great responsibility” 。了解工具是如何工作的才能最大限度发挥他的性能，希望这篇文章能对你有所帮助！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/22/promise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ruirui">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ruirui's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/22/promise/" itemprop="url">Promise 踩坑记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-22T16:01:23+08:00">2018-01-22</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在工作中遇到Promise的很多坑，一直想着对这些知识点进行总结。</p>
<p>javascript的异步处理，大多会想到通过回调函数来解决，但回调带来的问题也比较明显：</p>
<ol>
<li>在多层嵌套的回调函数中，无法判断什么时候完成异步，需要在外层作用域声明一些变量，这样容易被其他函数或变量修改。</li>
<li>因为异步函数在新的栈中运行，无法获取到之前栈的信息，之前的栈也无法捕获新的栈中抛出的错误，无法用try-catch处理错误。</li>
</ol>
<p>Promise可以将异步处理模块化，规范化。使得代码更简洁，优雅，可读性更好。</p>
<h3 id="基础用法："><a href="#基础用法：" class="headerlink" title="基础用法："></a>基础用法：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;.catch(<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// fail</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Promise 构造函数内有个执行器，将要进行的异步操作放入执行器中，Promise 实例一旦创建，执行器立即执行，执行器执行完毕后改变实例的状态，接着去执行相应的函数。<strong>Promise 的状态只能由执行器改变</strong>。</p>
<p>Promise 实例的特点：</p>
<ol>
<li>对象状态不受外部影响，只有内部执行器可以改变状态。</li>
<li>状态一旦改变，就不会再变，任何时候都可以得到这个结果。</li>
</ol>
<h3 id="Promise的链式调用"><a href="#Promise的链式调用" class="headerlink" title="Promise的链式调用"></a>Promise的链式调用</h3><p>Promise支持链式调用，因为调用.then方法每次都会<strong>返回新的 Promise 对象</strong>。<br>状态响应函数（即 then 方法）的返回值可以是以下三种</p>
<ol>
<li>一个 Promise 对象</li>
<li>一个同步的值或者是 undefined</li>
<li>同步的 throw 一个错误</li>
</ol>
<ul>
<li>如果返回的是一个 Promise 对象（即异步操作），那后一个回调函数（.then()方法），会等待该 Promise 对象状态发送变化，才会去执行。</li>
<li>如果返回一个同步的值，会默认“立刻”执行下一个.then()，如果不返回值，会传入一个 undefined，但不影响接下来的执行。同时将同步的值转化为 Promise 风格的代码。</li>
<li>如果.then 方法里 <code>throw new Error()</code>， 会被 catch 捕获到。</li>
</ul>
<h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h3><p>会返回一个 fulfilled 的 Promise 实例或原始的 Promise 实例。</p>
<p><code>Promise.resolve()</code>：当参数为空，返回一个状态为 fulfilled 的 Promise 实例。<br><code>Promise.resolve(object)</code>：当参数是 Promise 无关的值，同上，不过 fulfilled 响应函数会得到这个值。<br><code>Promise.resolve(promise)</code>：当参数是 Promise 实例，则返回该实例，不做任何修改。<br><code>Promise.resolve(thenable)</code>：当参数是.thenable，立刻执行 then 函数。</p>
<h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h3><p>返回一个使用接收到的值进行了 reject 的新的 Promise 对象。<br>和 <code>Promise.resolve()</code> 的区别是：当参数为 Promise 对象时，返回一个全新的 Promise 对象。</p>
<h3 id="Promise使用常见错误"><a href="#Promise使用常见错误" class="headerlink" title="Promise使用常见错误"></a>Promise使用常见错误</h3><h4 id="注意一：-then-方法每次返回一个新的-Promise-对象。区分链式调用和非链式调用"><a href="#注意一：-then-方法每次返回一个新的-Promise-对象。区分链式调用和非链式调用" class="headerlink" title="注意一：.then 方法每次返回一个新的 Promise 对象。区分链式调用和非链式调用"></a>注意一：.then 方法每次返回一个新的 Promise 对象。区分链式调用和非链式调用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1: 对同一个 Promise 对象同时调用 `then` 方法</span></span><br><span class="line"><span class="keyword">var</span> aPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">100</span>);</span><br><span class="line">&#125;);</span><br><span class="line">aPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line">aPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line">aPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// =&gt; 100</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 2: 对 `then` 进行 promise chain 方式进行调用</span></span><br><span class="line"><span class="keyword">var</span> bPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">100</span>);</span><br><span class="line">&#125;);</span><br><span class="line">bPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// =&gt; 100 * 2 * 2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>下面是一个由 then 方法导致的比较容易出错的例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">anAsyncCall</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> promise = doSomethingAsync();</span><br><span class="line">  promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    somethingComplicated();</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这种错误也是 Promise 的反模式，更多反模式参考<a href="http://efe.baidu.com/blog/promises-anti-pattern/" target="_blank" rel="noopener">这篇文章</a>。</p>
<p>这样会存在很多问题： 首先在 somethingComplicated 方法中产生的异常不会被外部捕获，此外，也不能得到 then 的返回值。当最后返回的是第一个 Promise 而不是 Promise 调用 then 方法后的结果，Promise 链也随机断掉。</p>
<p>正确的做法应该是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">anAsyncCall</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> promise = doSomethingAsync();</span><br><span class="line">    <span class="keyword">return</span> promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        somethingComplicated()</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">anAsyncCall</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doSomethingAsync().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        somethingComplicated()</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="注意二：-then-方法执行完必须将结果-return-出来。"><a href="#注意二：-then-方法执行完必须将结果-return-出来。" class="headerlink" title="注意二：.then 方法执行完必须将结果 return 出来。"></a>注意二：.then 方法执行完必须将结果 return 出来。</h4><p>.then 方法支持链式调用，不 return 的话，then 里的方法就会返回 undefined。所以要养成在 then 方法内部永远显式的调用 return 或throw 的习惯。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        resolve(<span class="number">100</span>);</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">Promise</span>.reject(value * <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// return Promise.reject(value * 2);</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">test().then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'true'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'false'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// true  undefined</span></span><br><span class="line"><span class="comment">// 如果.then将结果return出来，结果是</span></span><br><span class="line"><span class="comment">// false  200</span></span><br></pre></td></tr></table></figure>
<h4 id="注意三：catch-和-then-的区别"><a href="#注意三：catch-和-then-的区别" class="headerlink" title="注意三：catch 和 then 的区别"></a>注意三：catch 和 then 的区别</h4><p>catch 是 then 的语法糖，它是<code>then(null, rejection)</code>的别名，也就是当 Promise 对象状态变成 rejected 时会执行 catch，但是catch 调用完之后还是会返回一个 Promise 实例。</p>
<p>如果用 then，第一个回调抛出来的错误，第二个回调函数（then）不会捕获<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// I caught your error! :)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// I didn't catch your error! :(</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>即：当使用 <code>then(resolveHandler, rejectHandler)</code>，rejectHandler 不会捕获在 resolveHandler 中抛出的错误。<br>所以最好也不用 then 的第二个回调，转而用 catch 方法。</p>
<p>问题： .catch() 后面如果跟着 then() 会怎么处理？<br>.catch() 会返回 Promise 实例，如果不抛出错误，后面跟着 .then() 会执行，如果在 catch 中抛出错误，后面的 .then() 会跳过去，直接走向最后的 .catch()。</p>
<h4 id="注意四：永远传递一个函数到then方法里"><a href="#注意四：永远传递一个函数到then方法里" class="headerlink" title="注意四：永远传递一个函数到then方法里"></a>注意四：永远传递一个函数到then方法里</h4><p>看下面代码打印出什么？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>)</span><br><span class="line">.then(<span class="built_in">Promise</span>.resolve(<span class="string">'bar'</span>))</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>结果为：foo</p>
<p>当then方法接收一个非函数参数时，会解释为<code>then(null)</code>，导致之前的 Promise 的结果丢失，发生 Promise 穿透。</p>
<p>mdn上解释：</p>
<blockquote>
<p>如果忽略针对某个状态的回调函数参数，或者提供非函数 (nonfunction) 参数，那么 then 方法将会丢失关于该状态的回调函数信息，但是并不会产生错误。如果调用 then 的 Promise 的状态（fulfill 或 rejection）发生改变，但是 then 中并没有关于这种状态的回调函数，那么 then 将创建一个没有经过回调函数处理的新 Promise 对象，这个新 Promise 只是简单地接受调用这个 then 的原 Promise 的终态作为它的终态。</p>
</blockquote>
<p>所以，如果</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>)</span><br><span class="line">.then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'bar'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">// bar</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>最佳实践：</p>
<ul>
<li>回调函数中一定要使用 return 语句，避免丢失状态和结果。</li>
<li>在最后一定调用 catch 方法，用来捕获整体的异常。</li>
<li>永远传递函数给 then 方法。</li>
</ul>
<p>参考文章：</p>
<p><a href="http://liubin.org/promises-book/" target="_blank" rel="noopener">JavaScript Promise迷你书</a></p>
<p><a href="http://efe.baidu.com/blog/promises-anti-pattern/" target="_blank" rel="noopener">谈谈使用Promise时候的一些反模式</a></p>
<p><a href="https://segmentfault.com/a/1190000007395254" target="_blank" rel="noopener">Promise Anti-patterns</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/20/vue-dynamic-data-binding-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ruirui">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ruirui's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/20/vue-dynamic-data-binding-5/" itemprop="url">Vue 动态数据绑定（五）-- 实现简单的 MVVM</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-20T13:46:26+08:00">2017-10-20</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://ife.baidu.com/2017/course/detail/id/24" target="_blank" rel="noopener">任务说明地址</a></p>
<p>现在要实现最后一步了，如何在数据发生改变的时候，重新渲染 DOM。之前已经实现了数据绑定，模板渲染，现在考虑如何将这两者结合起来。<br>先上一张经典图来说明 vue 实现原理：<br><img src="vue.png" alt="vue"></p>
<p>Vue 数据绑定原理主要是通过数据劫持结合发布者-订阅者模式方式来实现的。每个实例对象属性都有相应的 watcher 实例对象，在渲染的时候记录属性依赖，数据更新的时候通知 watcher 重新渲染。在这主要有几个重要的概念：</p>
<ul>
<li><strong>Observer 监听器</strong>：主要对响应式对象的属性添加 getter/setter 方法，用于依赖收集和派发更新。</li>
<li><strong>Compile 解析器</strong>：实现模板指令的解析，以及绑定更新函数。</li>
<li><strong>Dep 订阅器</strong>：收集响应式对象的依赖关系，管理所有的观察者。</li>
<li><strong>Watcher 观察者</strong>：收到更新通知进行视图更新。</li>
</ul>
<h2 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h2><p>在之前实现的 Observer 里加入订阅器 Dep，实现观察者的管理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observer</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.data = data;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(data))&#123;</span><br><span class="line">    <span class="comment">// 暂不考虑数组</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.makeObserver(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Observer.prototype.makeObserver = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> data) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data.hasOwnProperty(i)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> data[i] === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">new</span> Observer(data[i]); <span class="comment">// 递归添加</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.getset(i, data[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Observer.prototype.getset = <span class="function"><span class="keyword">function</span> (<span class="params">i, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> val = value;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> dep = <span class="keyword">new</span> Dep(); <span class="comment">// 每个属性都有一个唯一的Dep与它对应</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>.data, i, &#123;</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'你访问了'</span> + i);</span><br><span class="line">      <span class="keyword">if</span>(Dep.target)&#123; <span class="comment">// 注意：这里进行收集依赖</span></span><br><span class="line">        dep.addSub(Dep.target);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params">newval</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'你设置了'</span> + i + <span class="string">',新的值为'</span> + newval);</span><br><span class="line">      <span class="keyword">if</span>(val === newval) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      val = newval;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">typeof</span> newval === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">new</span> Observer(val);</span><br><span class="line">      &#125;</span><br><span class="line">      dep.notify(); <span class="comment">// 通知订阅器的所有watcher更新</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个属性都有一个订阅器 Dep 与其对应，用来管理该属性的所有观察者。<br><strong>依赖收集</strong>是什么意思呢？对于一个模板 &#123;&#123; user.name &#125;&#125;，那么他的依赖就有 user.name 这个变量，<strong>依赖收集就是确定数据与视图的依赖关系</strong>。在触发 getter 的时候进行依赖收集，注意这里有一个重点：只有在 Dep.target 有值的时候才会进行依赖收集。也就是说，真正是因为 Vue 内部初始化数据的时候才去收集依赖，其他时候访问变量触发的 getter 就不进行收集，直接返回 value。 Dep.target是什么呢，看下面分析。<br><strong>派发更新</strong>：当数据改变了，调用该属性 Dep 订阅器的 notify 方法，通知该订阅器的所有 watcher 去更新视图。例如，页面上有两处访问了 user.name，那么 user.name 的订阅器里就会有两个 watcher ，当数据更新的时候，会通知这两个 watcher 进行更新。</p>
<h2 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h2><p>Dep 是依赖收集的容器，是一个 class。实际上是对 Watcher 的一种管理，记录哪些 Watcher 订阅了自己变化并在更新时进行通知。Dep 有个静态属性 target，是全局唯一的 Watcher。Dep 主要实现添加依赖 addSub 和通知 watcher 的更新 notify。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dep</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subs = []; <span class="comment">// 观察者合集</span></span><br><span class="line">&#125;</span><br><span class="line">Dep.target = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向subs数组添加依赖</span></span><br><span class="line">Dep.prototype.addSub = <span class="function"><span class="keyword">function</span> (<span class="params">sub</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subs.push(sub);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知所有订阅者更新</span></span><br><span class="line">Dep.prototype.notify = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subs.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    item.update();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h2><p>Watcher 是观察者，在初始化的时候需要将自己添加进订阅器 Dep 中，那如何添加呢？Observer 中的 getter 进行依赖收集的时候会执行添加观察者 Watcher 的操作，所以在初始化的时候只要触发了对应的 getter 就可以，也就是去获取一次属性值。如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Watcher</span>(<span class="params">vm, exp, cb</span>) </span>&#123;</span><br><span class="line">  Dep.target = <span class="keyword">this</span>; <span class="comment">// Watcher 初始化的时候，将Dep.target指向全局唯一的 Watcher</span></span><br><span class="line">  <span class="keyword">this</span>.vm = vm;</span><br><span class="line">  <span class="keyword">this</span>.cb = cb;</span><br><span class="line">  <span class="keyword">this</span>.exp = exp;</span><br><span class="line">  <span class="keyword">this</span>.get(); <span class="comment">// 获取值的时候会触发属性的 getter，这样就将观察者加入了订阅器中，然后清空Dep.target。</span></span><br><span class="line">  Dep.target = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">Watcher.prototype.get = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> CompileUtil.parse(<span class="keyword">this</span>.exp)(<span class="keyword">this</span>.vm.data); </span><br><span class="line">&#125;</span><br><span class="line">Watcher.prototype.update = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 观察者进行更新</span></span><br><span class="line">  <span class="keyword">this</span>.newVal = <span class="keyword">this</span>.get(); <span class="comment">// 获取新值，这个时候已经不会再将观察者加入订阅器中了，因为 Dep.target 已经为 null。</span></span><br><span class="line">  <span class="keyword">this</span>.cb(<span class="keyword">this</span>.newVal)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在初始化的时候Dep.target指向唯一的观察者，触发属性的 getter 添加监听，最后将 Dep.target 清空。<br>这儿有个 CompileUtil.parse 为了解析深层属性，返回最终的值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CompileUtil.parse = <span class="function"><span class="keyword">function</span>(<span class="params">exp</span>) </span>&#123; <span class="comment">// 解析多层路径</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="regexp">/[^\w.$]/</span>.test(exp)) <span class="keyword">return</span>; </span><br><span class="line">  <span class="keyword">var</span> exps = exp.split(<span class="string">'.'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = exps.length; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!obj) <span class="keyword">return</span>;</span><br><span class="line">        obj = obj[exps[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Compile"><a href="#Compile" class="headerlink" title="Compile"></a>Compile</h2><p>Compile解析器主要工作是两点</p>
<ol>
<li>解析模板指令，初始化模板视图。</li>
<li>绑定模板指令节点与更新方法，初始化订阅器。</li>
</ol>
<p>上节编译器 Compile 只是实现了第一点，现在要加上初始化的时候绑定更新的功能，在初始化视图的时候，初始化一个 watcher，此时将此 watcher 添加进该属性的 Dep 中，同时绑定更新函数，这样在数据更新的时候，调用此更新函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Compile.prototype.compileText = <span class="function"><span class="keyword">function</span> (<span class="params">node, exp</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 匹配 &#123;&#123; &#125;&#125;替换</span></span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> newVal = CompileUtil.parse(exp)(<span class="keyword">this</span>.vm.data);</span><br><span class="line">  <span class="keyword">this</span>.updateText(node, newVal); <span class="comment">// 初始化视图</span></span><br><span class="line">  <span class="keyword">new</span> Watcher(<span class="keyword">this</span>.vm, exp, <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;  <span class="comment">// 生成订阅器并绑定更新函数</span></span><br><span class="line">    self.updateText(node, value);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">Compile.prototype.updateText = <span class="function"><span class="keyword">function</span> (<span class="params">node, value</span>) </span>&#123; <span class="comment">// 只实现简单的替换</span></span><br><span class="line">  node.textContent = <span class="keyword">typeof</span> value == <span class="string">'undefined'</span> ? <span class="string">''</span> : value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，实现 vue 的初始化，根据上图，需要绑定 Observe 和 Compile 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.el = obj.el;</span><br><span class="line">  <span class="keyword">this</span>.data = obj.data;</span><br><span class="line">  <span class="keyword">new</span> Observer(<span class="keyword">this</span>.data);</span><br><span class="line">  <span class="keyword">new</span> Compile(<span class="keyword">this</span>.el, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现<a href="https://jsfiddle.net/ruirui/5jmtoL7u/" target="_blank" rel="noopener">代码</a></p>
<p>效果如下：</p>
<p><img src="demo.gif" alt="mvvm"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/10/vue-dynamic-data-binding-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ruirui">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ruirui's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/10/vue-dynamic-data-binding-4/" itemprop="url">Vue 动态数据绑定（四）-- 解析器 Compile</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-10T13:46:26+08:00">2017-09-10</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://ife.baidu.com/2017/course/detail/id/22" target="_blank" rel="noopener">任务说明地址</a></p>
<blockquote>
<p>将页面中代码片段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 页面中原本的 html 模板片段 --&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt;姓名：&#123;&#123;user.name&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;年龄：&#123;&#123;user.age&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>渲染成实际效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 最终在页面中渲染出来的结果 --&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt;姓名：youngwind&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;年龄：25&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>所以问题的关键：<strong>怎么实现一个解析器进行模板渲染</strong>?</p>
<p>简单的思路：深度遍历DOM模板，找到&#123;&#123;&#125;&#125;进行解析替换。<br>按照此思路实现一个简单的版本：<br>代码 <a href="https://jsfiddle.net/ruirui/mnkdjhpf/" target="_blank" rel="noopener">Demo</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function Compile(el, vm) &#123;</span><br><span class="line">  this.el = el;</span><br><span class="line">  this.vm = vm;</span><br><span class="line">  this.render();</span><br><span class="line">&#125;</span><br><span class="line">Compile.prototype.render = function () &#123;</span><br><span class="line">  var el = document.querySelector(this.el);</span><br><span class="line">  this.compile(el);</span><br><span class="line">&#125;</span><br><span class="line">Compile.prototype.compile = function (el) &#123;</span><br><span class="line">  // 递归遍历所有的dom子元素 找到 &#123;&#123;&#125;&#125; 进行替换</span><br><span class="line"></span><br><span class="line">  var childNodes = el.childNodes;</span><br><span class="line">  childNodes.forEach((item) =&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    if(item.nodeType === 1) &#123; // 元素节点</span><br><span class="line">      this.compile(item);</span><br><span class="line">    &#125; else if (item.nodeType === 3) &#123; // 文本内容</span><br><span class="line">      console.log(item.nodeValue);</span><br><span class="line">      var value = item.nodeValue.trim();</span><br><span class="line">      var reg = /&#123;&#123;(.*?)&#125;&#125;/;</span><br><span class="line">      if (value &amp;&amp; reg.test(value)) &#123;</span><br><span class="line">        this.compileText(item, reg.exec(value)[1]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">Compile.prototype.compileText = function(node, exp) &#123;</span><br><span class="line">  var newVal = this.parse(exp.trim())(this.vm.data);</span><br><span class="line">  node.textContent = typeof newVal == &apos;undefined&apos; ? &apos;&apos; : newVal;</span><br><span class="line">&#125;</span><br><span class="line">Compile.prototype.parse = function (exp) &#123; // 多层路径进行解析</span><br><span class="line">  if (/[^\w.$]/.test(exp)) return; </span><br><span class="line">  </span><br><span class="line">    var exps = exp.split(&apos;.&apos;);</span><br><span class="line">    return function(obj) &#123;</span><br><span class="line">      for (var i = 0, len = exps.length; i &lt; len; i++) &#123;</span><br><span class="line">          if (!obj) return;</span><br><span class="line">          obj = obj[exps[i]];</span><br><span class="line">      &#125;</span><br><span class="line">      return obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述实现方法是找到DOM直接替换，在遍历解析的时候有多次操作DOM节点，为了提高性能和效率，考虑用文档碎片fragment的方式。初始化时将节点转换成 fragment，解析完成再整体添加到真实的DOM节点中。</p>
<p>代码 <a href="https://jsfiddle.net/ruirui/phwoq2zk/" target="_blank" rel="noopener">DEMO</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Compile(el, vm) &#123;</span><br><span class="line">  this.el = el;</span><br><span class="line">  this.vm = vm;</span><br><span class="line">  this.fragement = this.nodeToFragment(document.querySelector(this.el));</span><br><span class="line">  this.compile(this.fragement);</span><br><span class="line">  document.querySelector(this.el).appendChild(this.fragement);</span><br><span class="line">&#125;</span><br><span class="line">Compile.prototype.nodeToFragment = function(el) &#123;</span><br><span class="line">  var fragment = document.createDocumentFragment();</span><br><span class="line">  var child = el.firstChild;</span><br><span class="line">  while (child) &#123;</span><br><span class="line">    fragment.appendChild(child); // 将Dom元素移入fragment中 注意： append的时候 原来的dom会删掉挂载在文档碎片上</span><br><span class="line">    child = el.firstChild;</span><br><span class="line">  &#125;</span><br><span class="line">  return fragment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">ruirui</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ruirui</span>

  

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.0.0</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.0"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
